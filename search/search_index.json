{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Docs Version \u00b6 blessed at 10edaa088bf239b8dbfac363cb757ac6941c9a90 . blessed-contrib at 555163ff8d034687d3964447e67cbd40aea4f6b7 .","title":"Docs Version"},{"location":"#docs-version","text":"blessed at 10edaa088bf239b8dbfac363cb757ac6941c9a90 . blessed-contrib at 555163ff8d034687d3964447e67cbd40aea4f6b7 .","title":"Docs Version"},{"location":"mechanics/artificial-cursors/","text":"Artificial Cursors \u00b6 Terminal cursors can be tricky. They all have different custom escape codes to alter. As an experimental alternative, blessed can draw a cursor for you, allowing you to have a custom cursor that you control. var screen = blessed . screen ({ cursor : { artificial : true , shape : 'line' , blink : true , color : null // null for default } }); That's it. It's controlled the same way as the regular cursor. To create a custom cursor: var screen = blessed . screen ({ cursor : { artificial : true , shape : { bg : 'red' , fg : 'white' , bold : true , ch : '#' }, blink : true } });","title":"Artificial Cursors"},{"location":"mechanics/artificial-cursors/#artificial-cursors","text":"Terminal cursors can be tricky. They all have different custom escape codes to alter. As an experimental alternative, blessed can draw a cursor for you, allowing you to have a custom cursor that you control. var screen = blessed . screen ({ cursor : { artificial : true , shape : 'line' , blink : true , color : null // null for default } }); That's it. It's controlled the same way as the regular cursor. To create a custom cursor: var screen = blessed . screen ({ cursor : { artificial : true , shape : { bg : 'red' , fg : 'white' , bold : true , ch : '#' }, blink : true } });","title":"Artificial Cursors"},{"location":"mechanics/content-and-tags/","text":"Content & Tags \u00b6 Every element can have text content via setContent . If tags : true was passed to the element's constructor, the content can contain tags. For example: box . setContent ( 'hello {red-fg}{green-bg}{bold}world{/bold}{/green-bg}{/red-fg}' ); To make this more concise {/} cancels all character attributes. box . setContent ( 'hello {red-fg}{green-bg}{bold}world{/}' ); Colors \u00b6 Blessed tags support the basic 16 colors for colors, as well as up to 256 colors. box . setContent ( 'hello {red-fg}{green-bg}world{/}' ); Tags can also use hex colors (which will be reduced to the most accurate terminal color): box . setContent ( 'hello {#ff0000-fg}{#00ff00-bg}world{/}' ); Attributes \u00b6 Blessed supports all terminal attributes, including bold , underline , blink , inverse , and invisible . box . setContent ( 'hello {bold}world{/bold}' ); Alignment \u00b6 Newlines and alignment are also possible in content. box . setContent ( 'hello\\n' + '{right}world{/right}\\n' + '{center}foo{/center}\\n' ); + 'left{|}right' ); This will produce a box that looks like: | hello | | world | | foo | | left right | Escaping \u00b6 Escaping can either be done using blessed.escape() box . setContent ( 'here is an escaped tag: ' + blessed . escape ( '{bold}{/bold}' )); Or with the special {open} and {close} tags: box . setContent ( 'here is an escaped tag: {open}bold{close}{open}/bold{close}' ); Either will produce: here is an escaped tag: {bold}{/bold} SGR Sequences \u00b6 Content can also handle SGR escape codes. This means if you got output from a program, say git log for example, you can feed it directly to an element's content and the colors will be parsed appropriately. This means that while {red-fg}foo{/red-fg} produces ^[[31mfoo^[[39m , you could just feed ^[[31mfoo^[[39m directly to the content.","title":"Content & Tags"},{"location":"mechanics/content-and-tags/#content-tags","text":"Every element can have text content via setContent . If tags : true was passed to the element's constructor, the content can contain tags. For example: box . setContent ( 'hello {red-fg}{green-bg}{bold}world{/bold}{/green-bg}{/red-fg}' ); To make this more concise {/} cancels all character attributes. box . setContent ( 'hello {red-fg}{green-bg}{bold}world{/}' );","title":"Content &amp; Tags"},{"location":"mechanics/content-and-tags/#colors","text":"Blessed tags support the basic 16 colors for colors, as well as up to 256 colors. box . setContent ( 'hello {red-fg}{green-bg}world{/}' ); Tags can also use hex colors (which will be reduced to the most accurate terminal color): box . setContent ( 'hello {#ff0000-fg}{#00ff00-bg}world{/}' );","title":"Colors"},{"location":"mechanics/content-and-tags/#attributes","text":"Blessed supports all terminal attributes, including bold , underline , blink , inverse , and invisible . box . setContent ( 'hello {bold}world{/bold}' );","title":"Attributes"},{"location":"mechanics/content-and-tags/#alignment","text":"Newlines and alignment are also possible in content. box . setContent ( 'hello\\n' + '{right}world{/right}\\n' + '{center}foo{/center}\\n' ); + 'left{|}right' ); This will produce a box that looks like: | hello | | world | | foo | | left right |","title":"Alignment"},{"location":"mechanics/content-and-tags/#escaping","text":"Escaping can either be done using blessed.escape() box . setContent ( 'here is an escaped tag: ' + blessed . escape ( '{bold}{/bold}' )); Or with the special {open} and {close} tags: box . setContent ( 'here is an escaped tag: {open}bold{close}{open}/bold{close}' ); Either will produce: here is an escaped tag: {bold}{/bold}","title":"Escaping"},{"location":"mechanics/content-and-tags/#sgr-sequences","text":"Content can also handle SGR escape codes. This means if you got output from a program, say git log for example, you can feed it directly to an element's content and the colors will be parsed appropriately. This means that while {red-fg}foo{/red-fg} produces ^[[31mfoo^[[39m , you could just feed ^[[31mfoo^[[39m directly to the content.","title":"SGR Sequences"},{"location":"mechanics/events/","text":"Events \u00b6 Events in Blessed work similar to the traditional node.js model, with one important difference: they have a concept of a tree and event bubbling. Event Bubbling \u00b6 Events can bubble in blessed. For example: Receiving all click events for box (a normal event listener): box . on ( 'click' , function ( mouse ) { box . setContent ( 'You clicked ' + mouse . x + ', ' + mouse . y + '.' ); screen . render (); }); Receiving all click events for box , as well as all of its children: box . on ( 'element click' , function ( el , mouse ) { box . setContent ( 'You clicked ' + el . type + ' at ' + mouse . x + ', ' + mouse . y + '.' ); screen . render (); if ( el === box ) { return false ; // Cancel propagation. } }); el gets passed in as the first argument. It refers to the target element the event occurred on. Returning false will cancel propagation up the tree.","title":"Events"},{"location":"mechanics/events/#events","text":"Events in Blessed work similar to the traditional node.js model, with one important difference: they have a concept of a tree and event bubbling.","title":"Events"},{"location":"mechanics/events/#event-bubbling","text":"Events can bubble in blessed. For example: Receiving all click events for box (a normal event listener): box . on ( 'click' , function ( mouse ) { box . setContent ( 'You clicked ' + mouse . x + ', ' + mouse . y + '.' ); screen . render (); }); Receiving all click events for box , as well as all of its children: box . on ( 'element click' , function ( el , mouse ) { box . setContent ( 'You clicked ' + el . type + ' at ' + mouse . x + ', ' + mouse . y + '.' ); screen . render (); if ( el === box ) { return false ; // Cancel propagation. } }); el gets passed in as the first argument. It refers to the target element the event occurred on. Returning false will cancel propagation up the tree.","title":"Event Bubbling"},{"location":"mechanics/multiple-screens/","text":"Multiple Screens \u00b6 Blessed supports the ability to create multiple screens. This may not seem useful at first, but if you're writing a program that serves terminal interfaces over http, telnet, or any other protocol, this can be very useful. Server Side Usage \u00b6 A simple telnet server might look like this (see examples/blessed-telnet.js for a full example): var blessed = require ( 'blessed' ); var telnet = require ( 'telnet2' ); telnet ({ tty : true }, function ( client ) { client . on ( 'term' , function ( terminal ) { screen . terminal = terminal ; screen . render (); }); client . on ( 'size' , function ( width , height ) { client . columns = width ; client . rows = height ; client . emit ( 'resize' ); }); var screen = blessed . screen ({ smartCSR : true , input : client , output : client , terminal : 'xterm-256color' , fullUnicode : true }); client . on ( 'close' , function () { if ( ! screen . destroyed ) { screen . destroy (); } }); screen . key ([ 'C-c' , 'q' ], function ( ch , key ) { screen . destroy (); }); screen . on ( 'destroy' , function () { if ( client . writable ) { client . destroy (); } }); screen . data . main = blessed . box ({ parent : screen , left : 'center' , top : 'center' , width : '80%' , height : '90%' , border : 'line' , content : 'Welcome to my server. Here is your own private session.' }); screen . render (); }). listen ( 2300 ); Once you've written something similar and started it, you can simply telnet into your blessed app: $ telnet localhost 2300 Creating a netcat server would also work as long as you disable line buffering and terminal echo on the commandline via stty : $ stty -icanon -echo ; ncat localhost 2300 ; stty icanon echo Or by using netcat's -t option: $ ncat -t localhost 2300 Creating a streaming http 1.1 server than runs in the terminal is possible by curling it with special arguments: $ curl -sSNT. localhost:8080 . There are currently no examples of netcat/nc/ncat or http->curl servers yet. The blessed.screen constructor can accept input , output , and term arguments to aid with this. The multiple screens will be managed internally by blessed. The programmer just has to keep track of the references, however, to avoid ambiguity, it's possible to explicitly dictate which screen a node is part of by using the screen option when creating an element. The screen.destroy() method is also crucial: this will clean up all event listeners the screen has bound and make sure it stops listening on the event loop. Make absolutely certain to remember to clean up your screens once you're done with them. A tricky part is making sure to include the ability for the client to send the TERM which is reset on the serverside, and the terminal size, which is should also be reset on the serverside. Both of these capabilities are demonstrated above. For a working example of a blessed telnet server, see examples/blessed-telnet.js .","title":"Multiple Screens"},{"location":"mechanics/multiple-screens/#multiple-screens","text":"Blessed supports the ability to create multiple screens. This may not seem useful at first, but if you're writing a program that serves terminal interfaces over http, telnet, or any other protocol, this can be very useful.","title":"Multiple Screens"},{"location":"mechanics/multiple-screens/#server-side-usage","text":"A simple telnet server might look like this (see examples/blessed-telnet.js for a full example): var blessed = require ( 'blessed' ); var telnet = require ( 'telnet2' ); telnet ({ tty : true }, function ( client ) { client . on ( 'term' , function ( terminal ) { screen . terminal = terminal ; screen . render (); }); client . on ( 'size' , function ( width , height ) { client . columns = width ; client . rows = height ; client . emit ( 'resize' ); }); var screen = blessed . screen ({ smartCSR : true , input : client , output : client , terminal : 'xterm-256color' , fullUnicode : true }); client . on ( 'close' , function () { if ( ! screen . destroyed ) { screen . destroy (); } }); screen . key ([ 'C-c' , 'q' ], function ( ch , key ) { screen . destroy (); }); screen . on ( 'destroy' , function () { if ( client . writable ) { client . destroy (); } }); screen . data . main = blessed . box ({ parent : screen , left : 'center' , top : 'center' , width : '80%' , height : '90%' , border : 'line' , content : 'Welcome to my server. Here is your own private session.' }); screen . render (); }). listen ( 2300 ); Once you've written something similar and started it, you can simply telnet into your blessed app: $ telnet localhost 2300 Creating a netcat server would also work as long as you disable line buffering and terminal echo on the commandline via stty : $ stty -icanon -echo ; ncat localhost 2300 ; stty icanon echo Or by using netcat's -t option: $ ncat -t localhost 2300 Creating a streaming http 1.1 server than runs in the terminal is possible by curling it with special arguments: $ curl -sSNT. localhost:8080 . There are currently no examples of netcat/nc/ncat or http->curl servers yet. The blessed.screen constructor can accept input , output , and term arguments to aid with this. The multiple screens will be managed internally by blessed. The programmer just has to keep track of the references, however, to avoid ambiguity, it's possible to explicitly dictate which screen a node is part of by using the screen option when creating an element. The screen.destroy() method is also crucial: this will clean up all event listeners the screen has bound and make sure it stops listening on the event loop. Make absolutely certain to remember to clean up your screens once you're done with them. A tricky part is making sure to include the ability for the client to send the TERM which is reset on the serverside, and the terminal size, which is should also be reset on the serverside. Both of these capabilities are demonstrated above. For a working example of a blessed telnet server, see examples/blessed-telnet.js .","title":"Server Side Usage"},{"location":"mechanics/positioning/","text":"Positioning \u00b6 Offsets may be a number, a percentage (e.g. 50% ), or a keyword (e.g. center ). Dimensions may be a number, or a percentage (e.g. 50% ). Positions are treated almost exactly the same as they are in CSS/CSSOM when an element has the position : absolute CSS property. When an element is created, it can be given coordinates in its constructor: var box = blessed . box ({ left : 'center' , top : 'center' , bg : 'yellow' , width : '50%' , height : '50%' }); This tells blessed to create a box, perfectly centered relative to its parent , 50% as wide and 50% as tall as its parent. Percentages can also have offsets applied to them: ... height : '50%-1' , left : '45%+1' , ... To access the calculated offsets, relative to the parent: console . log ( box . left ); console . log ( box . top ); To access the calculated offsets, absolute (relative to the screen): console . log ( box . aleft ); console . log ( box . atop ); Overlapping offsets and dimensions greater than parents' \u00b6 This still needs to be tested a bit, but it should work.","title":"Positioning"},{"location":"mechanics/positioning/#positioning","text":"Offsets may be a number, a percentage (e.g. 50% ), or a keyword (e.g. center ). Dimensions may be a number, or a percentage (e.g. 50% ). Positions are treated almost exactly the same as they are in CSS/CSSOM when an element has the position : absolute CSS property. When an element is created, it can be given coordinates in its constructor: var box = blessed . box ({ left : 'center' , top : 'center' , bg : 'yellow' , width : '50%' , height : '50%' }); This tells blessed to create a box, perfectly centered relative to its parent , 50% as wide and 50% as tall as its parent. Percentages can also have offsets applied to them: ... height : '50%-1' , left : '45%+1' , ... To access the calculated offsets, relative to the parent: console . log ( box . left ); console . log ( box . top ); To access the calculated offsets, absolute (relative to the screen): console . log ( box . aleft ); console . log ( box . atop );","title":"Positioning"},{"location":"mechanics/positioning/#overlapping-offsets-and-dimensions-greater-than-parents","text":"This still needs to be tested a bit, but it should work.","title":"Overlapping offsets and dimensions greater than parents'"},{"location":"mechanics/rendering/","text":"Rendering \u00b6 To actually render the screen buffer, you must call render . box . setContent ( 'Hello {#0fe1ab-fg}world{/}.' ); screen . render (); Elements are rendered with the lower elements in the children array being painted first. In terms of the painter's algorithm, the lowest indicies in the array are the furthest away, just like in the DOM.","title":"Rendering"},{"location":"mechanics/rendering/#rendering","text":"To actually render the screen buffer, you must call render . box . setContent ( 'Hello {#0fe1ab-fg}world{/}.' ); screen . render (); Elements are rendered with the lower elements in the children array being painted first. In terms of the painter's algorithm, the lowest indicies in the array are the furthest away, just like in the DOM.","title":"Rendering"},{"location":"mechanics/style/","text":"Style \u00b6 The style option controls most of the visual aspects of an element. style : { fg : 'blue' , bg : 'black' , bold : true , underline : false , blink : false , inverse : false , invisible : false , transparent : false , border : { fg : 'blue' , bg : 'red' }, scrollbar : { bg : 'blue' }, focus : { bg : 'red' }, hover : { bg : 'red' } } Colors \u00b6 Colors can be the names of any of the 16 basic terminal colors, along with hex values (e.g. #ff0000 ) for 256 color terminals. If 256 or 88 colors is not supported. Blessed with reduce the color to whatever is available. Attributes \u00b6 Blessed supports all terminal attributes, including bold , underline , blink , inverse , and invisible . Attributes are represented as bools in the style object. Transparency \u00b6 Blessed can set the opacity of an element to 50% using style.transparent = true; . While this seems like it normally shouldn't be possible in a terminal, blessed will use a color blending algorithm to blend the element of the foremost element with the background behind it. Obviously characters cannot be blended, but background colors can. Shadow \u00b6 Translucent shadows are also an option when it comes to styling an element. This option will create a 50% opacity 2-cell wide, 1-cell high shadow offset to the bottom-right. shadow : true Effects \u00b6 Blessed supports hover and focus styles. (Hover is only useful is mouse input is enabled). style : { hover : { bg : 'red' }, focus : { border : { fg : 'blue' } } } Scrollbar \u00b6 On scrollable elements, blessed will support style options for the scrollbar, such as: style : { scrollbar : { bg : 'red' , fg : 'blue' } } As a main option, scrollbar will either take a bool or an object: scrollbar : { ch : ' ' } Or: scrollbar : true","title":"Style"},{"location":"mechanics/style/#style","text":"The style option controls most of the visual aspects of an element. style : { fg : 'blue' , bg : 'black' , bold : true , underline : false , blink : false , inverse : false , invisible : false , transparent : false , border : { fg : 'blue' , bg : 'red' }, scrollbar : { bg : 'blue' }, focus : { bg : 'red' }, hover : { bg : 'red' } }","title":"Style"},{"location":"mechanics/style/#colors","text":"Colors can be the names of any of the 16 basic terminal colors, along with hex values (e.g. #ff0000 ) for 256 color terminals. If 256 or 88 colors is not supported. Blessed with reduce the color to whatever is available.","title":"Colors"},{"location":"mechanics/style/#attributes","text":"Blessed supports all terminal attributes, including bold , underline , blink , inverse , and invisible . Attributes are represented as bools in the style object.","title":"Attributes"},{"location":"mechanics/style/#transparency","text":"Blessed can set the opacity of an element to 50% using style.transparent = true; . While this seems like it normally shouldn't be possible in a terminal, blessed will use a color blending algorithm to blend the element of the foremost element with the background behind it. Obviously characters cannot be blended, but background colors can.","title":"Transparency"},{"location":"mechanics/style/#shadow","text":"Translucent shadows are also an option when it comes to styling an element. This option will create a 50% opacity 2-cell wide, 1-cell high shadow offset to the bottom-right. shadow : true","title":"Shadow"},{"location":"mechanics/style/#effects","text":"Blessed supports hover and focus styles. (Hover is only useful is mouse input is enabled). style : { hover : { bg : 'red' }, focus : { border : { fg : 'blue' } } }","title":"Effects"},{"location":"mechanics/style/#scrollbar","text":"On scrollable elements, blessed will support style options for the scrollbar, such as: style : { scrollbar : { bg : 'red' , fg : 'blue' } } As a main option, scrollbar will either take a bool or an object: scrollbar : { ch : ' ' } Or: scrollbar : true","title":"Scrollbar"},{"location":"notes/FAQ/","text":"FAQ \u00b6 Why doesn't the Linux console render lines correctly on Ubuntu? You need to install the ncurses-base package and the ncurses-term package. (#98) Why do vertical lines look chopped up in iTerm2? All ACS vertical lines look this way in iTerm2 with the default font. Why can't I use my mouse in Terminal.app? Terminal.app does not support mouse events. Why doesn't the OverlayImage element appear in my terminal? The OverlayImage element uses w3m to display images. This generally only works on X11+xterm/urxvt, but it may work on other unix terminals. Why can't my mouse clicks register beyond 255 cells? Older versions of VTE do not support any modern mouse protocol. On top of that, the old X10 protocol it does implement is bugged. Through several workarounds we've managed to get the cell limit from 127 to 255 . If you're not happy with this, you may want to look into using xterm or urxvt, or a terminal which uses a modern VTE, like gnome-terminal. Is blessed efficient? Yes. Blessed implements CSR and uses the painter's algorithm to render the screen. It maintains two screen buffers so it only needs to render what has changed on the terminal screen. Will blessed work with all terminals? Yes. Blessed has a terminfo/termcap parser and compiler that was written from scratch. It should work with every terminal as long as a terminfo file is provided. If you notice any compatibility issues in your termial, do not hesitate to post an issue. What is \"curses\" and \"ncurses\"? [\"curses\"][curses] was an old library written in the early days of unix which allowed a programmer to easily manipulate the cursor in order to render the screen. \"ncurses\" is a free reimplementation of curses. It improved upon it quite a bit by focusing more on terminal compatibility and is now the standard library for implementing terminal programs. Blessed uses neither of these, and instead handles terminal compatibility itself. What is the difference between blessed and blessed-contrib? blessed is a major piece of code which reimplements curses from the ground up. A UI API is then layered on top of this. blessed-contrib is a popular library built on top of blessed which makes clever use of modules to implement useful widgets like graphs, ascii art, and so on. Are there blessed-like solutions for non-javascript platforms? Yes. There are some fantastic solutions out there. - Perl: Curses::UI - Python: Urwid - Go: termui & termbox-go","title":"FAQ"},{"location":"notes/FAQ/#faq","text":"Why doesn't the Linux console render lines correctly on Ubuntu? You need to install the ncurses-base package and the ncurses-term package. (#98) Why do vertical lines look chopped up in iTerm2? All ACS vertical lines look this way in iTerm2 with the default font. Why can't I use my mouse in Terminal.app? Terminal.app does not support mouse events. Why doesn't the OverlayImage element appear in my terminal? The OverlayImage element uses w3m to display images. This generally only works on X11+xterm/urxvt, but it may work on other unix terminals. Why can't my mouse clicks register beyond 255 cells? Older versions of VTE do not support any modern mouse protocol. On top of that, the old X10 protocol it does implement is bugged. Through several workarounds we've managed to get the cell limit from 127 to 255 . If you're not happy with this, you may want to look into using xterm or urxvt, or a terminal which uses a modern VTE, like gnome-terminal. Is blessed efficient? Yes. Blessed implements CSR and uses the painter's algorithm to render the screen. It maintains two screen buffers so it only needs to render what has changed on the terminal screen. Will blessed work with all terminals? Yes. Blessed has a terminfo/termcap parser and compiler that was written from scratch. It should work with every terminal as long as a terminfo file is provided. If you notice any compatibility issues in your termial, do not hesitate to post an issue. What is \"curses\" and \"ncurses\"? [\"curses\"][curses] was an old library written in the early days of unix which allowed a programmer to easily manipulate the cursor in order to render the screen. \"ncurses\" is a free reimplementation of curses. It improved upon it quite a bit by focusing more on terminal compatibility and is now the standard library for implementing terminal programs. Blessed uses neither of these, and instead handles terminal compatibility itself. What is the difference between blessed and blessed-contrib? blessed is a major piece of code which reimplements curses from the ground up. A UI API is then layered on top of this. blessed-contrib is a popular library built on top of blessed which makes clever use of modules to implement useful widgets like graphs, ascii art, and so on. Are there blessed-like solutions for non-javascript platforms? Yes. There are some fantastic solutions out there. - Perl: Curses::UI - Python: Urwid - Go: termui & termbox-go","title":"FAQ"},{"location":"notes/examples/","text":"Examples \u00b6 Examples can be found in examples/ .","title":"Examples"},{"location":"notes/examples/#examples","text":"Examples can be found in examples/ .","title":"Examples"},{"location":"notes/low-level-usage/","text":"Low-level Usage \u00b6 This will actually parse the xterm terminfo and compile every string capability to a javascript function: var blessed = require ( 'blessed' ); var tput = blessed . tput ({ terminal : 'xterm-256color' , extended : true }); process . stdout . write ( tput . setaf ( 4 ) + 'Hello' + tput . sgr0 () + '\\n' ); To play around with it on the command line, it works just like tput: $ tput.js setaf 2 $ tput.js sgr0 $ echo \" $( tput.js setaf 2 ) Hello World $( tput.js sgr0 ) \" The main functionality is exposed in the main blessed module: var blessed = require ( 'blessed' ) , program = blessed . program (); program . key ( 'q' , function ( ch , key ) { program . clear (); program . disableMouse (); program . showCursor (); program . normalBuffer (); process . exit ( 0 ); }); program . on ( 'mouse' , function ( data ) { if ( data . action === 'mousemove' ) { program . move ( data . x , data . y ); program . bg ( 'red' ); program . write ( 'x' ); program . bg ( '!red' ); } }); program . alternateBuffer (); program . enableMouse (); program . hideCursor (); program . clear (); program . move ( 1 , 1 ); program . bg ( 'black' ); program . write ( 'Hello world' , 'blue fg' ); program . setx (( program . cols / 2 | 0 ) - 4 ); program . down ( 5 ); program . write ( 'Hi again!' ); program . bg ( '!black' ); program . feed ();","title":"Low level usage"},{"location":"notes/low-level-usage/#low-level-usage","text":"This will actually parse the xterm terminfo and compile every string capability to a javascript function: var blessed = require ( 'blessed' ); var tput = blessed . tput ({ terminal : 'xterm-256color' , extended : true }); process . stdout . write ( tput . setaf ( 4 ) + 'Hello' + tput . sgr0 () + '\\n' ); To play around with it on the command line, it works just like tput: $ tput.js setaf 2 $ tput.js sgr0 $ echo \" $( tput.js setaf 2 ) Hello World $( tput.js sgr0 ) \" The main functionality is exposed in the main blessed module: var blessed = require ( 'blessed' ) , program = blessed . program (); program . key ( 'q' , function ( ch , key ) { program . clear (); program . disableMouse (); program . showCursor (); program . normalBuffer (); process . exit ( 0 ); }); program . on ( 'mouse' , function ( data ) { if ( data . action === 'mousemove' ) { program . move ( data . x , data . y ); program . bg ( 'red' ); program . write ( 'x' ); program . bg ( '!red' ); } }); program . alternateBuffer (); program . enableMouse (); program . hideCursor (); program . clear (); program . move ( 1 , 1 ); program . bg ( 'black' ); program . write ( 'Hello world' , 'blue fg' ); program . setx (( program . cols / 2 | 0 ) - 4 ); program . down ( 5 ); program . write ( 'Hi again!' ); program . bg ( '!black' ); program . feed ();","title":"Low-level Usage"},{"location":"notes/testing/","text":"Testing \u00b6 Most tests contained in the test/ directory are interactive. It's up to the programmer to determine whether the test is properly displayed. In the future it might be better to do something similar to vttest.","title":"Testing"},{"location":"notes/testing/#testing","text":"Most tests contained in the test/ directory are interactive. It's up to the programmer to determine whether the test is properly displayed. In the future it might be better to do something similar to vttest.","title":"Testing"},{"location":"notes/windows-compatibility/","text":"Windows Compatibility \u00b6 Currently there is no mouse or resize event support on Windows. Windows users will need to explicitly set term when creating a screen like so ( NOTE : This is no longer necessary as of the latest versions of blessed. This is now handled automatically): var screen = blessed . screen ({ terminal : 'windows-ansi' });","title":"Windows Compatibility"},{"location":"notes/windows-compatibility/#windows-compatibility","text":"Currently there is no mouse or resize event support on Windows. Windows users will need to explicitly set term when creating a screen like so ( NOTE : This is no longer necessary as of the latest versions of blessed. This is now handled automatically): var screen = blessed . screen ({ terminal : 'windows-ansi' });","title":"Windows Compatibility"},{"location":"other/Helpers/","text":"Helpers \u00b6 All helpers reside on blessed.helpers or blessed . merge(a, b) - Merge objects a and b into object a . asort(obj) - Sort array alphabetically by name prop. hsort(obj) - Sort array numerically by index prop. findFile(start, target) - Find a file at start directory with name target . escape(text) - Escape content's tags to be passed into el.setContent() . Example: box.setContent('escaped tag: ' + blessed.escape('{bold}{/bold}')); parseTags(text) - Parse tags into SGR escape codes. generateTags(style, text) - Generate text tags based on style object. attrToBinary(style, element) - Convert style attributes to binary format. stripTags(text) - Strip text of tags and SGR sequences. cleanTags(text) - Strip text of tags, SGR escape code, and leading/trailing whitespace. dropUnicode(text) - Drop text of any >U+FFFF characters.","title":"Helpers"},{"location":"other/Helpers/#helpers","text":"All helpers reside on blessed.helpers or blessed . merge(a, b) - Merge objects a and b into object a . asort(obj) - Sort array alphabetically by name prop. hsort(obj) - Sort array numerically by index prop. findFile(start, target) - Find a file at start directory with name target . escape(text) - Escape content's tags to be passed into el.setContent() . Example: box.setContent('escaped tag: ' + blessed.escape('{bold}{/bold}')); parseTags(text) - Parse tags into SGR escape codes. generateTags(style, text) - Generate text tags based on style object. attrToBinary(style, element) - Convert style attributes to binary format. stripTags(text) - Strip text of tags and SGR sequences. cleanTags(text) - Strip text of tags, SGR escape code, and leading/trailing whitespace. dropUnicode(text) - Drop text of any >U+FFFF characters.","title":"Helpers"},{"location":"widgets/base-nodes/Element (abstract)/","text":"Element (from Node) \u00b6 The base element. Options \u00b6 fg, bg, bold, underline - Attributes. style - May contain attributes in the format of: { fg : 'blue' , bg : 'black' , border : { fg : 'blue' }, scrollbar : { bg : 'blue' }, focus : { bg : 'red' }, hover : { bg : 'red' } } border - Border object, see below. content - Element's text content. clickable - Element is clickable. input, keyable - Element is focusable and can receive key input. focused - Element is focused. hidden - Whether the element is hidden. label - A simple text label for the element. hoverText - A floating text label for the element which appears on mouseover. align - Text alignment: left , center , or right . valign - Vertical text alignment: top , middle , or bottom . shrink - Shrink/flex/grow to content and child elements. Width/height during render. padding - Amount of padding on the inside of the element. Can be a number or an object containing the properties: left , right , top , and bottom . width, height - Width/height of the element, can be a number, percentage ( 0-100% ), or keyword ( half or shrink ). Percentages can also have offsets ( 50%+1 , 50%-1 ). left, right, top, bottom - Offsets of the element relative to its parent . Can be a number, percentage ( 0-100% ), or keyword ( center ). right and bottom do not accept keywords. Percentages can also have offsets ( 50%+1 , 50%-1 ). position - Can contain the above options. scrollable - Whether the element is scrollable or not. ch - Background character (default is whitespace ). draggable - Allow the element to be dragged with the mouse. shadow - Draw a translucent offset shadow behind the element. Properties \u00b6 Inherits all from Node. name - Name of the element. Useful for form submission. border - Border object. type - Type of border ( line or bg ). bg by default. ch - Character to use if bg type, default is space. bg, fg - Border foreground and background, must be numbers (-1 for default). bold, underline - Border attributes. style - Contains attributes (e.g. fg/bg/underline ). See above. position - Raw width, height, and offsets. content - Raw text content. hidden - Whether the element is hidden or not. visible - Whether the element is visible or not. detached - Whether the element is attached to a screen in its ancestry somewhere. fg, bg - Foreground and background, must be numbers (-1 for default). bold, underline - Attributes. width - Calculated width. height - Calculated height. left - Calculated relative left offset. right - Calculated relative right offset. top - Calculated relative top offset. bottom - Calculated relative bottom offset. aleft - Calculated absolute left offset. aright - Calculated absolute right offset. atop - Calculated absolute top offset. abottom - Calculated absolute bottom offset. draggable - Whether the element is draggable. Set to true to allow dragging. Events \u00b6 Inherits all from Node. blur, focus - Received when an element is focused or unfocused. mouse - Received on mouse events for this element. mousedown, mouseup - Mouse button was pressed or released. wheeldown, wheelup - Wheel was scrolled down or up. mouseover, mouseout - Element was hovered or unhovered. mousemove - Mouse was moved somewhere on this element. click - Element was clicked (slightly smarter than mouseup). keypress - Received on key events for this element. move - Received when the element is moved. resize - Received when the element is resized. key [name] - Received on key event for [name]. prerender - Received before a call to render. render - Received after a call to render. hide - Received when element becomes hidden. show - Received when element is shown. destroy - Received when element is destroyed. Methods \u00b6 Inherits all from Node. Note: If the scrollable option is enabled, Element inherits all methods from ScrollableBox. render() - Write content and children to the screen buffer. hide() - Hide element. show() - Show element. toggle() - Toggle hidden/shown. focus() - Focus element. key(name, listener) - Bind a keypress listener for a specific key. onceKey(name, listener) - Bind a keypress listener for a specific key once. unkey(name, listener) - Remove a keypress listener for a specific key. onScreenEvent(type, handler) - Same as el.on('screen', ...) except this will automatically keep track of which listeners are bound to the screen object. For use with removeScreenEvent() , free() , and destroy() . removeScreenEvent(type, handler) - Same as el.removeListener('screen', ...) except this will automatically keep track of which listeners are bound to the screen object. For use with onScreenEvent() , free() , and destroy() . free() - Free up the element. Automatically unbind all events that may have been bound to the screen object. This prevents memory leaks. For use with onScreenEvent() , removeScreenEvent() , and destroy() . destroy() - Same as the detach() method, except this will automatically call free() and unbind any screen events to prevent memory leaks. for use with onScreenEvent() , removeScreenEvent() , and free() . setIndex(z) - Set the z-index of the element (changes rendering order). setFront() - Put the element in front of its siblings. setBack() - Put the element in back of its siblings. setLabel(text/options) - Set the label text for the top-left corner. Example options: {text:'foo',side:'left'} removeLabel() - Remove the label completely. setHover(text/options) - Set a hover text box to follow the cursor. Similar to the \"title\" DOM attribute in the browser. Example options: {text:'foo'} removeHover() - Remove the hover label completely. enableMouse() - Enable mouse events for the element (automatically called when a form of on('mouse') is bound). enableKeys() - Enable keypress events for the element (automatically called when a form of on('keypress') is bound). enableInput() - Enable key and mouse events. Calls bot enableMouse and enableKeys. enableDrag() - Enable dragging of the element. disableDrag() - Disable dragging of the element. screenshot([xi, xl, yi, yl]) - Take an SGR screenshot of the element within the region. Returns a string containing only characters and SGR codes. Can be displayed by simply echoing it in a terminal. Content Methods \u00b6 Methods for dealing with text content, line by line. Useful for writing a text editor, irc client, etc. Note: All of these methods deal with pre-aligned, pre-wrapped text. If you use deleteTop() on a box with a wrapped line at the top, it may remove 3-4 \"real\" lines (rows) depending on how long the original line was. The lines parameter can be a string or an array of strings. The line parameter must be a string. setContent(text) - Set the content. Note: When text is input, it will be stripped of all non-SGR escape codes, tabs will be replaced with 8 spaces, and tags will be replaced with SGR codes (if enabled). getContent() - Return content, slightly different from el.content . Assume the above formatting. setText(text) - Similar to setContent , but ignore tags and remove escape codes. getText() - Similar to getContent , but return content with tags and escape codes removed. insertLine(i, lines) - Insert a line into the box's content. deleteLine(i) - Delete a line from the box's content. getLine(i) - Get a line from the box's content. getBaseLine(i) - Get a line from the box's content from the visible top. setLine(i, line) - Set a line in the box's content. setBaseLine(i, line) - Set a line in the box's content from the visible top. clearLine(i) - Clear a line from the box's content. clearBaseLine(i) - Clear a line from the box's content from the visible top. insertTop(lines) - Insert a line at the top of the box. insertBottom(lines) - Insert a line at the bottom of the box. deleteTop() - Delete a line at the top of the box. deleteBottom() - Delete a line at the bottom of the box. unshiftLine(lines) - Unshift a line onto the top of the content. shiftLine(i) - Shift a line off the top of the content. pushLine(lines) - Push a line onto the bottom of the content. popLine(i) - Pop a line off the bottom of the content. getLines() - An array containing the content lines. getScreenLines() - An array containing the lines as they are displayed on the screen. strWidth(text) - Get a string's displayed width, taking into account double-width, surrogate pairs, combining characters, tags, and SGR escape codes.","title":"Element (from Node)"},{"location":"widgets/base-nodes/Element (abstract)/#element-from-node","text":"The base element.","title":"Element (from Node)"},{"location":"widgets/base-nodes/Element (abstract)/#options","text":"fg, bg, bold, underline - Attributes. style - May contain attributes in the format of: { fg : 'blue' , bg : 'black' , border : { fg : 'blue' }, scrollbar : { bg : 'blue' }, focus : { bg : 'red' }, hover : { bg : 'red' } } border - Border object, see below. content - Element's text content. clickable - Element is clickable. input, keyable - Element is focusable and can receive key input. focused - Element is focused. hidden - Whether the element is hidden. label - A simple text label for the element. hoverText - A floating text label for the element which appears on mouseover. align - Text alignment: left , center , or right . valign - Vertical text alignment: top , middle , or bottom . shrink - Shrink/flex/grow to content and child elements. Width/height during render. padding - Amount of padding on the inside of the element. Can be a number or an object containing the properties: left , right , top , and bottom . width, height - Width/height of the element, can be a number, percentage ( 0-100% ), or keyword ( half or shrink ). Percentages can also have offsets ( 50%+1 , 50%-1 ). left, right, top, bottom - Offsets of the element relative to its parent . Can be a number, percentage ( 0-100% ), or keyword ( center ). right and bottom do not accept keywords. Percentages can also have offsets ( 50%+1 , 50%-1 ). position - Can contain the above options. scrollable - Whether the element is scrollable or not. ch - Background character (default is whitespace ). draggable - Allow the element to be dragged with the mouse. shadow - Draw a translucent offset shadow behind the element.","title":"Options"},{"location":"widgets/base-nodes/Element (abstract)/#properties","text":"Inherits all from Node. name - Name of the element. Useful for form submission. border - Border object. type - Type of border ( line or bg ). bg by default. ch - Character to use if bg type, default is space. bg, fg - Border foreground and background, must be numbers (-1 for default). bold, underline - Border attributes. style - Contains attributes (e.g. fg/bg/underline ). See above. position - Raw width, height, and offsets. content - Raw text content. hidden - Whether the element is hidden or not. visible - Whether the element is visible or not. detached - Whether the element is attached to a screen in its ancestry somewhere. fg, bg - Foreground and background, must be numbers (-1 for default). bold, underline - Attributes. width - Calculated width. height - Calculated height. left - Calculated relative left offset. right - Calculated relative right offset. top - Calculated relative top offset. bottom - Calculated relative bottom offset. aleft - Calculated absolute left offset. aright - Calculated absolute right offset. atop - Calculated absolute top offset. abottom - Calculated absolute bottom offset. draggable - Whether the element is draggable. Set to true to allow dragging.","title":"Properties"},{"location":"widgets/base-nodes/Element (abstract)/#events","text":"Inherits all from Node. blur, focus - Received when an element is focused or unfocused. mouse - Received on mouse events for this element. mousedown, mouseup - Mouse button was pressed or released. wheeldown, wheelup - Wheel was scrolled down or up. mouseover, mouseout - Element was hovered or unhovered. mousemove - Mouse was moved somewhere on this element. click - Element was clicked (slightly smarter than mouseup). keypress - Received on key events for this element. move - Received when the element is moved. resize - Received when the element is resized. key [name] - Received on key event for [name]. prerender - Received before a call to render. render - Received after a call to render. hide - Received when element becomes hidden. show - Received when element is shown. destroy - Received when element is destroyed.","title":"Events"},{"location":"widgets/base-nodes/Element (abstract)/#methods","text":"Inherits all from Node. Note: If the scrollable option is enabled, Element inherits all methods from ScrollableBox. render() - Write content and children to the screen buffer. hide() - Hide element. show() - Show element. toggle() - Toggle hidden/shown. focus() - Focus element. key(name, listener) - Bind a keypress listener for a specific key. onceKey(name, listener) - Bind a keypress listener for a specific key once. unkey(name, listener) - Remove a keypress listener for a specific key. onScreenEvent(type, handler) - Same as el.on('screen', ...) except this will automatically keep track of which listeners are bound to the screen object. For use with removeScreenEvent() , free() , and destroy() . removeScreenEvent(type, handler) - Same as el.removeListener('screen', ...) except this will automatically keep track of which listeners are bound to the screen object. For use with onScreenEvent() , free() , and destroy() . free() - Free up the element. Automatically unbind all events that may have been bound to the screen object. This prevents memory leaks. For use with onScreenEvent() , removeScreenEvent() , and destroy() . destroy() - Same as the detach() method, except this will automatically call free() and unbind any screen events to prevent memory leaks. for use with onScreenEvent() , removeScreenEvent() , and free() . setIndex(z) - Set the z-index of the element (changes rendering order). setFront() - Put the element in front of its siblings. setBack() - Put the element in back of its siblings. setLabel(text/options) - Set the label text for the top-left corner. Example options: {text:'foo',side:'left'} removeLabel() - Remove the label completely. setHover(text/options) - Set a hover text box to follow the cursor. Similar to the \"title\" DOM attribute in the browser. Example options: {text:'foo'} removeHover() - Remove the hover label completely. enableMouse() - Enable mouse events for the element (automatically called when a form of on('mouse') is bound). enableKeys() - Enable keypress events for the element (automatically called when a form of on('keypress') is bound). enableInput() - Enable key and mouse events. Calls bot enableMouse and enableKeys. enableDrag() - Enable dragging of the element. disableDrag() - Disable dragging of the element. screenshot([xi, xl, yi, yl]) - Take an SGR screenshot of the element within the region. Returns a string containing only characters and SGR codes. Can be displayed by simply echoing it in a terminal.","title":"Methods"},{"location":"widgets/base-nodes/Element (abstract)/#content-methods","text":"Methods for dealing with text content, line by line. Useful for writing a text editor, irc client, etc. Note: All of these methods deal with pre-aligned, pre-wrapped text. If you use deleteTop() on a box with a wrapped line at the top, it may remove 3-4 \"real\" lines (rows) depending on how long the original line was. The lines parameter can be a string or an array of strings. The line parameter must be a string. setContent(text) - Set the content. Note: When text is input, it will be stripped of all non-SGR escape codes, tabs will be replaced with 8 spaces, and tags will be replaced with SGR codes (if enabled). getContent() - Return content, slightly different from el.content . Assume the above formatting. setText(text) - Similar to setContent , but ignore tags and remove escape codes. getText() - Similar to getContent , but return content with tags and escape codes removed. insertLine(i, lines) - Insert a line into the box's content. deleteLine(i) - Delete a line from the box's content. getLine(i) - Get a line from the box's content. getBaseLine(i) - Get a line from the box's content from the visible top. setLine(i, line) - Set a line in the box's content. setBaseLine(i, line) - Set a line in the box's content from the visible top. clearLine(i) - Clear a line from the box's content. clearBaseLine(i) - Clear a line from the box's content from the visible top. insertTop(lines) - Insert a line at the top of the box. insertBottom(lines) - Insert a line at the bottom of the box. deleteTop() - Delete a line at the top of the box. deleteBottom() - Delete a line at the bottom of the box. unshiftLine(lines) - Unshift a line onto the top of the content. shiftLine(i) - Shift a line off the top of the content. pushLine(lines) - Push a line onto the bottom of the content. popLine(i) - Pop a line off the bottom of the content. getLines() - An array containing the content lines. getScreenLines() - An array containing the lines as they are displayed on the screen. strWidth(text) - Get a string's displayed width, taking into account double-width, surrogate pairs, combining characters, tags, and SGR escape codes.","title":"Content Methods"},{"location":"widgets/base-nodes/Node (abstract)/","text":"Node (from EventEmitter) \u00b6 The base node which everything inherits from. Options \u00b6 screen - The screen to be associated with. parent - The desired parent. children - An arrray of children. Properties \u00b6 Inherits all from EventEmitter. type - Type of the node (e.g. box ). options - Original options object. parent - Parent node. screen - Parent screen. children - Array of node's children. data, _, $ - An object for any miscellanous user data. index - Render index (document order index) of the last render call. Events \u00b6 Inherits all from EventEmitter. adopt - Received when node is added to a parent. remove - Received when node is removed from it's current parent. reparent - Received when node gains a new parent. attach - Received when node is attached to the screen directly or somewhere in its ancestry. detach - Received when node is detached from the screen directly or somewhere in its ancestry. Methods \u00b6 Inherits all from EventEmitter. prepend(node) - Prepend a node to this node's children. append(node) - Append a node to this node's children. remove(node) - Remove child node from node. insert(node, i) - Insert a node to this node's children at index i . insertBefore(node, refNode) - Insert a node to this node's children before the reference node. insertAfter(node, refNode) - Insert a node from node after the reference node. detach() - Remove node from its parent. emitDescendants(type, args..., [iterator]) - Emit event for element, and recursively emit same event for all descendants. get(name, [default]) - Get user property with a potential default value. set(name, value) - Set user property to value.","title":"Node (from EventEmitter)"},{"location":"widgets/base-nodes/Node (abstract)/#node-from-eventemitter","text":"The base node which everything inherits from.","title":"Node (from EventEmitter)"},{"location":"widgets/base-nodes/Node (abstract)/#options","text":"screen - The screen to be associated with. parent - The desired parent. children - An arrray of children.","title":"Options"},{"location":"widgets/base-nodes/Node (abstract)/#properties","text":"Inherits all from EventEmitter. type - Type of the node (e.g. box ). options - Original options object. parent - Parent node. screen - Parent screen. children - Array of node's children. data, _, $ - An object for any miscellanous user data. index - Render index (document order index) of the last render call.","title":"Properties"},{"location":"widgets/base-nodes/Node (abstract)/#events","text":"Inherits all from EventEmitter. adopt - Received when node is added to a parent. remove - Received when node is removed from it's current parent. reparent - Received when node gains a new parent. attach - Received when node is attached to the screen directly or somewhere in its ancestry. detach - Received when node is detached from the screen directly or somewhere in its ancestry.","title":"Events"},{"location":"widgets/base-nodes/Node (abstract)/#methods","text":"Inherits all from EventEmitter. prepend(node) - Prepend a node to this node's children. append(node) - Append a node to this node's children. remove(node) - Remove child node from node. insert(node, i) - Insert a node to this node's children at index i . insertBefore(node, refNode) - Insert a node to this node's children before the reference node. insertAfter(node, refNode) - Insert a node from node after the reference node. detach() - Remove node from its parent. emitDescendants(type, args..., [iterator]) - Emit event for element, and recursively emit same event for all descendants. get(name, [default]) - Get user property with a potential default value. set(name, value) - Set user property to value.","title":"Methods"},{"location":"widgets/base-nodes/Screen (from Node)/","text":"Screen (from Node) \u00b6 The screen on which every other node renders. Options \u00b6 program - The blessed Program to be associated with. Will be automatically instantiated if none is provided. smartCSR - Attempt to perform CSR optimization on all possible elements (not just full-width ones, elements with uniform cells to their sides). This is known to cause flickering with elements that are not full-width, however, it is more optimal for terminal rendering. fastCSR - Do CSR on any element within 20 cols of the screen edge on either side. Faster than smartCSR , but may cause flickering depending on what is on each side of the element. useBCE - Attempt to perform back_color_erase optimizations for terminals that support it. It will also work with terminals that don't support it, but only on lines with the default background color. As it stands with the current implementation, it's uncertain how much terminal performance this adds at the cost of overhead within node. resizeTimeout - Amount of time (in ms) to redraw the screen after the terminal is resized (Default: 300). tabSize - The width of tabs within an element's content. autoPadding - Automatically position child elements with border and padding in mind ( NOTE : this is a recommended option. It may become default in the future). cursor.artificial - Have blessed draw a custom cursor and hide the terminal cursor ( experimental ). cursor.shape - Shape of the cursor. Can be: block, underline, or line. cursor.blink - Whether the cursor blinks. cursor.color - Color of the color. Accepts any valid color value ( null is default). log - Create a log file. See log method. dump - Dump all output and input to desired file. Can be used together with log option if set as a boolean. debug - Debug mode. Enables usage of the debug method. Also creates a debug console which will display when pressing F12. It will display all log and debug messages. ignoreLocked - Array of keys in their full format (e.g. C-c ) to ignore when keys are locked or grabbed. Useful for creating a key that will always exit no matter whether the keys are locked. dockBorders - Automatically \"dock\" borders with other elements instead of overlapping, depending on position ( experimental ). For example: These border-overlapped elements: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 box1 \u2502 box2 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Become: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 box1 \u2502 box2 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ignoreDockContrast - Normally, dockable borders will not dock if the colors or attributes are different. This option will allow them to dock regardless. It may produce some odd looking multi-colored borders though. fullUnicode - Allow for rendering of East Asian double-width characters, utf-16 surrogate pairs, and unicode combining characters. This allows you to display text above the basic multilingual plane. This is behind an option because it may affect performance slightly negatively. Without this option enabled, all double-width, surrogate pair, and combining characters will be replaced by '??' , '?' , '' respectively. (NOTE: iTerm2 cannot display combining characters properly. Blessed simply removes them from an element's content if iTerm2 is detected). sendFocus - Send focus events after mouse is enabled. warnings - Display warnings (such as the output not being a TTY, similar to ncurses). forceUnicode - Force blessed to use unicode even if it is not detected via terminfo, env variables, or windows code page. If value is true unicode is forced. If value is false non-unicode is forced (default: null ). input/output - Input and output streams. proc es s.stdin / proc es s.stdout by default, however, it could be a net.Socket if you want to make a program that runs over telnet or something of that nature. terminal - TERM name used for terminfo parsing. The $TERM env variable is used by default. title - Set the terminal window title if possible. Properties \u00b6 Inherits all from Node. program - The blessed Program object. tput - The blessed Tput object (only available if you passed tput : true to the Program constructor.) focused - Top of the focus history stack. width - Width of the screen (same as program.cols ). height - Height of the screen (same as program.rows ). cols - Same as screen.width . rows - Same as screen.height . left - Relative left offset, always zero. right - Relative right offset, always zero. top - Relative top offset, always zero. bottom - Relative bottom offset, always zero. aleft - Absolute left offset, always zero. aright - Absolute right offset, always zero. atop - Absolute top offset, always zero. abottom - Absolute bottom offset, always zero. grabKeys - Whether the focused element grabs all keypresses. lockKeys - Prevent keypresses from being received by any element. hover - The currently hovered element. Only set if mouse events are bound. terminal - Set or get terminal name. Set calls screen.setTerminal() internally. title - Set or get window title. Events \u00b6 Inherits all from Node. resize - Received on screen resize. mouse - Received on mouse events. keypress - Received on key events. element [name] - Global events received for all elements. key [name] - Received on key event for [name]. focus, blur - Received when the terminal window focuses/blurs. Requires a terminal supporting the focus protocol and focus needs to be passed to program.enableMouse(). prerender - Received before render. render - Received on render. warning - Received when blessed notices something untoward (output is not a tty, terminfo not found, etc). destroy - Received when the screen is destroyed (only useful when using multiple screens). Methods \u00b6 Inherits all from Node. log(msg, ...) - Write string to the log file if one was created. debug(msg, ...) - Same as the log method, but only gets called if the debug option was set. alloc() - Allocate a new pending screen buffer and a new output screen buffer. realloc() - Reallocate the screen buffers and clear the screen. draw(start, end) - Draw the screen based on the contents of the screen buffer. render() - Render all child elements, writing all data to the screen buffer and drawing the screen. clearRegion(x1, x2, y1, y2) - Clear any region on the screen. fillRegion(attr, ch, x1, x2, y1, y2) - Fill any region with a character of a certain attribute. focusOffset(offset) - Focus element by offset of focusable elements. focusPrevious() - Focus previous element in the index. focusNext() - Focus next element in the index. focusPush(element) - Push element on the focus stack (equivalent to screen.focused = el ). focusPop() - Pop element off the focus stack. saveFocus() - Save the focused element. restoreFocus() - Restore the saved focused element. rewindFocus() - \"Rewind\" focus to the last visible and attached element. key(name, listener) - Bind a keypress listener for a specific key. onceKey(name, listener) - Bind a keypress listener for a specific key once. unkey(name, listener) - Remove a keypress listener for a specific key. spawn(file, args, options) - Spawn a process in the foreground, return to blessed app after exit. exec(file, args, options, callback) - Spawn a process in the foreground, return to blessed app after exit. Executes callback on error or exit. readEditor([options], callback) - Read data from text editor. setEffects(el, fel, over, out, effects, temp) - Set effects based on two events and attributes. insertLine(n, y, top, bottom) - Insert a line into the screen (using csr: this bypasses the output buffer). deleteLine(n, y, top, bottom) - Delete a line from the screen (using csr: this bypasses the output buffer). insertBottom(top, bottom) - Insert a line at the bottom of the screen. insertTop(top, bottom) - Insert a line at the top of the screen. deleteBottom(top, bottom) - Delete a line at the bottom of the screen. deleteTop(top, bottom) - Delete a line at the top of the screen. enableMouse([el]) - Enable mouse events for the screen and optionally an element (automatically called when a form of on('mouse') is bound). enableKeys([el]) - Enable keypress events for the screen and optionally an element (automatically called when a form of on('keypress') is bound). enableInput([el]) - Enable key and mouse events. Calls bot enableMouse and enableKeys. copyToClipboard(text) - Attempt to copy text to clipboard using iTerm2's proprietary sequence. Returns true if successful. cursorShape(shape, blink) - Attempt to change cursor shape. Will not work in all terminals (see artificial cursors for a solution to this). Returns true if successful. cursorColor(color) - Attempt to change cursor color. Returns true if successful. cursorReset() - Attempt to reset cursor. Returns true if successful. screenshot([xi, xl, yi, yl]) - Take an SGR screenshot of the screen within the region. Returns a string containing only characters and SGR codes. Can be displayed by simply echoing it in a terminal. destroy() - Destroy the screen object and remove it from the global list. Also remove all global events relevant to the screen object. If all screen objects are destroyed, the node process is essentially reset to its initial state. setTerminal(term) - Reset the terminal to term . Reloads terminfo.","title":"Screen (from Node)"},{"location":"widgets/base-nodes/Screen (from Node)/#screen-from-node","text":"The screen on which every other node renders.","title":"Screen (from Node)"},{"location":"widgets/base-nodes/Screen (from Node)/#options","text":"program - The blessed Program to be associated with. Will be automatically instantiated if none is provided. smartCSR - Attempt to perform CSR optimization on all possible elements (not just full-width ones, elements with uniform cells to their sides). This is known to cause flickering with elements that are not full-width, however, it is more optimal for terminal rendering. fastCSR - Do CSR on any element within 20 cols of the screen edge on either side. Faster than smartCSR , but may cause flickering depending on what is on each side of the element. useBCE - Attempt to perform back_color_erase optimizations for terminals that support it. It will also work with terminals that don't support it, but only on lines with the default background color. As it stands with the current implementation, it's uncertain how much terminal performance this adds at the cost of overhead within node. resizeTimeout - Amount of time (in ms) to redraw the screen after the terminal is resized (Default: 300). tabSize - The width of tabs within an element's content. autoPadding - Automatically position child elements with border and padding in mind ( NOTE : this is a recommended option. It may become default in the future). cursor.artificial - Have blessed draw a custom cursor and hide the terminal cursor ( experimental ). cursor.shape - Shape of the cursor. Can be: block, underline, or line. cursor.blink - Whether the cursor blinks. cursor.color - Color of the color. Accepts any valid color value ( null is default). log - Create a log file. See log method. dump - Dump all output and input to desired file. Can be used together with log option if set as a boolean. debug - Debug mode. Enables usage of the debug method. Also creates a debug console which will display when pressing F12. It will display all log and debug messages. ignoreLocked - Array of keys in their full format (e.g. C-c ) to ignore when keys are locked or grabbed. Useful for creating a key that will always exit no matter whether the keys are locked. dockBorders - Automatically \"dock\" borders with other elements instead of overlapping, depending on position ( experimental ). For example: These border-overlapped elements: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 box1 \u2502 box2 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Become: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 box1 \u2502 box2 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ignoreDockContrast - Normally, dockable borders will not dock if the colors or attributes are different. This option will allow them to dock regardless. It may produce some odd looking multi-colored borders though. fullUnicode - Allow for rendering of East Asian double-width characters, utf-16 surrogate pairs, and unicode combining characters. This allows you to display text above the basic multilingual plane. This is behind an option because it may affect performance slightly negatively. Without this option enabled, all double-width, surrogate pair, and combining characters will be replaced by '??' , '?' , '' respectively. (NOTE: iTerm2 cannot display combining characters properly. Blessed simply removes them from an element's content if iTerm2 is detected). sendFocus - Send focus events after mouse is enabled. warnings - Display warnings (such as the output not being a TTY, similar to ncurses). forceUnicode - Force blessed to use unicode even if it is not detected via terminfo, env variables, or windows code page. If value is true unicode is forced. If value is false non-unicode is forced (default: null ). input/output - Input and output streams. proc es s.stdin / proc es s.stdout by default, however, it could be a net.Socket if you want to make a program that runs over telnet or something of that nature. terminal - TERM name used for terminfo parsing. The $TERM env variable is used by default. title - Set the terminal window title if possible.","title":"Options"},{"location":"widgets/base-nodes/Screen (from Node)/#properties","text":"Inherits all from Node. program - The blessed Program object. tput - The blessed Tput object (only available if you passed tput : true to the Program constructor.) focused - Top of the focus history stack. width - Width of the screen (same as program.cols ). height - Height of the screen (same as program.rows ). cols - Same as screen.width . rows - Same as screen.height . left - Relative left offset, always zero. right - Relative right offset, always zero. top - Relative top offset, always zero. bottom - Relative bottom offset, always zero. aleft - Absolute left offset, always zero. aright - Absolute right offset, always zero. atop - Absolute top offset, always zero. abottom - Absolute bottom offset, always zero. grabKeys - Whether the focused element grabs all keypresses. lockKeys - Prevent keypresses from being received by any element. hover - The currently hovered element. Only set if mouse events are bound. terminal - Set or get terminal name. Set calls screen.setTerminal() internally. title - Set or get window title.","title":"Properties"},{"location":"widgets/base-nodes/Screen (from Node)/#events","text":"Inherits all from Node. resize - Received on screen resize. mouse - Received on mouse events. keypress - Received on key events. element [name] - Global events received for all elements. key [name] - Received on key event for [name]. focus, blur - Received when the terminal window focuses/blurs. Requires a terminal supporting the focus protocol and focus needs to be passed to program.enableMouse(). prerender - Received before render. render - Received on render. warning - Received when blessed notices something untoward (output is not a tty, terminfo not found, etc). destroy - Received when the screen is destroyed (only useful when using multiple screens).","title":"Events"},{"location":"widgets/base-nodes/Screen (from Node)/#methods","text":"Inherits all from Node. log(msg, ...) - Write string to the log file if one was created. debug(msg, ...) - Same as the log method, but only gets called if the debug option was set. alloc() - Allocate a new pending screen buffer and a new output screen buffer. realloc() - Reallocate the screen buffers and clear the screen. draw(start, end) - Draw the screen based on the contents of the screen buffer. render() - Render all child elements, writing all data to the screen buffer and drawing the screen. clearRegion(x1, x2, y1, y2) - Clear any region on the screen. fillRegion(attr, ch, x1, x2, y1, y2) - Fill any region with a character of a certain attribute. focusOffset(offset) - Focus element by offset of focusable elements. focusPrevious() - Focus previous element in the index. focusNext() - Focus next element in the index. focusPush(element) - Push element on the focus stack (equivalent to screen.focused = el ). focusPop() - Pop element off the focus stack. saveFocus() - Save the focused element. restoreFocus() - Restore the saved focused element. rewindFocus() - \"Rewind\" focus to the last visible and attached element. key(name, listener) - Bind a keypress listener for a specific key. onceKey(name, listener) - Bind a keypress listener for a specific key once. unkey(name, listener) - Remove a keypress listener for a specific key. spawn(file, args, options) - Spawn a process in the foreground, return to blessed app after exit. exec(file, args, options, callback) - Spawn a process in the foreground, return to blessed app after exit. Executes callback on error or exit. readEditor([options], callback) - Read data from text editor. setEffects(el, fel, over, out, effects, temp) - Set effects based on two events and attributes. insertLine(n, y, top, bottom) - Insert a line into the screen (using csr: this bypasses the output buffer). deleteLine(n, y, top, bottom) - Delete a line from the screen (using csr: this bypasses the output buffer). insertBottom(top, bottom) - Insert a line at the bottom of the screen. insertTop(top, bottom) - Insert a line at the top of the screen. deleteBottom(top, bottom) - Delete a line at the bottom of the screen. deleteTop(top, bottom) - Delete a line at the top of the screen. enableMouse([el]) - Enable mouse events for the screen and optionally an element (automatically called when a form of on('mouse') is bound). enableKeys([el]) - Enable keypress events for the screen and optionally an element (automatically called when a form of on('keypress') is bound). enableInput([el]) - Enable key and mouse events. Calls bot enableMouse and enableKeys. copyToClipboard(text) - Attempt to copy text to clipboard using iTerm2's proprietary sequence. Returns true if successful. cursorShape(shape, blink) - Attempt to change cursor shape. Will not work in all terminals (see artificial cursors for a solution to this). Returns true if successful. cursorColor(color) - Attempt to change cursor color. Returns true if successful. cursorReset() - Attempt to reset cursor. Returns true if successful. screenshot([xi, xl, yi, yl]) - Take an SGR screenshot of the screen within the region. Returns a string containing only characters and SGR codes. Can be displayed by simply echoing it in a terminal. destroy() - Destroy the screen object and remove it from the global list. Also remove all global events relevant to the screen object. If all screen objects are destroyed, the node process is essentially reset to its initial state. setTerminal(term) - Reset the terminal to term . Reloads terminfo.","title":"Methods"},{"location":"widgets/blessed-contrib/","text":"blessed-contrib \u00b6 This subpage contains documentation for yaronn/blessed-contrib .","title":"blessed-contrib"},{"location":"widgets/blessed-contrib/#blessed-contrib","text":"This subpage contains documentation for yaronn/blessed-contrib .","title":"blessed-contrib"},{"location":"widgets/blessed-contrib/LCD-display/","text":"LCD Display \u00b6 var lcd = contrib . lcd ( { segmentWidth : 0.06 // how wide are the segments in % so 50% = 0.5 , segmentInterval : 0.11 // spacing between the segments in % so 50% = 0.550% = 0.5 , strokeWidth : 0.11 // spacing between the segments in % so 50% = 0.5 , elements : 4 // how many elements in the display. or how many characters can be displayed. , display : 321 // what should be displayed before first call to setDisplay , elementSpacing : 4 // spacing between each element , elementPadding : 2 // how far away from the edges to put the elements , color : 'white' // color for the segments , label : 'Storage Remaining' }) lcd . setDisplay ( 23 + 'G' ); // will display \"23G\" lcd . setOptions ({}) // adjust options at runtime Please see the examples/lcd.js for an example. The example provides keybindings to adjust the segmentWidth and segmentInterval and strokeWidth in real-time so that you can see how they manipulate the look and feel.","title":"LCD Display"},{"location":"widgets/blessed-contrib/LCD-display/#lcd-display","text":"var lcd = contrib . lcd ( { segmentWidth : 0.06 // how wide are the segments in % so 50% = 0.5 , segmentInterval : 0.11 // spacing between the segments in % so 50% = 0.550% = 0.5 , strokeWidth : 0.11 // spacing between the segments in % so 50% = 0.5 , elements : 4 // how many elements in the display. or how many characters can be displayed. , display : 321 // what should be displayed before first call to setDisplay , elementSpacing : 4 // spacing between each element , elementPadding : 2 // how far away from the edges to put the elements , color : 'white' // color for the segments , label : 'Storage Remaining' }) lcd . setDisplay ( 23 + 'G' ); // will display \"23G\" lcd . setOptions ({}) // adjust options at runtime Please see the examples/lcd.js for an example. The example provides keybindings to adjust the segmentWidth and segmentInterval and strokeWidth in real-time so that you can see how they manipulate the look and feel.","title":"LCD Display"},{"location":"widgets/blessed-contrib/bar-chart/","text":"Bar Chart \u00b6 var bar = contrib . bar ( { label : 'Server Utilization (%)' , barWidth : 4 , barSpacing : 6 , xOffset : 0 , maxHeight : 9 }) screen . append ( bar ) //must append before setting data bar . setData ( { titles : [ 'bar1' , 'bar2' ] , data : [ 5 , 10 ]})","title":"Bar Chart"},{"location":"widgets/blessed-contrib/bar-chart/#bar-chart","text":"var bar = contrib . bar ( { label : 'Server Utilization (%)' , barWidth : 4 , barSpacing : 6 , xOffset : 0 , maxHeight : 9 }) screen . append ( bar ) //must append before setting data bar . setData ( { titles : [ 'bar1' , 'bar2' ] , data : [ 5 , 10 ]})","title":"Bar Chart"},{"location":"widgets/blessed-contrib/colors/","text":"Colors \u00b6 You can use 256 colors ( source ): function randomColor () { return [ Math . random () * 255 , Math . random () * 255 , Math . random () * 255 ] } line = contrib . line ( { ... , style : { line : randomColor (), text : randomColor (), baseline : randomColor () } })","title":"Colors"},{"location":"widgets/blessed-contrib/colors/#colors","text":"You can use 256 colors ( source ): function randomColor () { return [ Math . random () * 255 , Math . random () * 255 , Math . random () * 255 ] } line = contrib . line ( { ... , style : { line : randomColor (), text : randomColor (), baseline : randomColor () } })","title":"Colors"},{"location":"widgets/blessed-contrib/donut/","text":"Donut \u00b6 var donut = contrib . donut ({ label : 'Test' , radius : 8 , arcWidth : 3 , remainColor : 'black' , yPadding : 2 , data : [ { percent : 80 , label : 'web1' , color : 'green' } ] }); Data passed in uses percent and label to draw the donut graph. Color is optional and defaults to green. donut . setData ([ { percent : 87 , label : 'rcp' , 'color' : 'green' }, { percent : 43 , label : 'rcp' , 'color' : 'cyan' }, ]); Updating the donut is as easy as passing in an array to setData using the same array format as in the constructor. Pass in as many objects to the array of data as you want, they will automatically resize and try to fit. However, please note that you will still be restricted to actual screen space.","title":"Donut"},{"location":"widgets/blessed-contrib/donut/#donut","text":"var donut = contrib . donut ({ label : 'Test' , radius : 8 , arcWidth : 3 , remainColor : 'black' , yPadding : 2 , data : [ { percent : 80 , label : 'web1' , color : 'green' } ] }); Data passed in uses percent and label to draw the donut graph. Color is optional and defaults to green. donut . setData ([ { percent : 87 , label : 'rcp' , 'color' : 'green' }, { percent : 43 , label : 'rcp' , 'color' : 'cyan' }, ]); Updating the donut is as easy as passing in an array to setData using the same array format as in the constructor. Pass in as many objects to the array of data as you want, they will automatically resize and try to fit. However, please note that you will still be restricted to actual screen space.","title":"Donut"},{"location":"widgets/blessed-contrib/gauge/","text":"Gauge \u00b6 var gauge = contrib . gauge ({ label : 'Progress' , stroke : 'green' , fill : 'white' }) gauge . setPercent ( 25 )","title":"Gauge"},{"location":"widgets/blessed-contrib/gauge/#gauge","text":"var gauge = contrib . gauge ({ label : 'Progress' , stroke : 'green' , fill : 'white' }) gauge . setPercent ( 25 )","title":"Gauge"},{"location":"widgets/blessed-contrib/line-chart/","text":"Line Chart \u00b6 var line = contrib . line ( { style : { line : \"yellow\" , text : \"green\" , baseline : \"black\" } , xLabelPadding : 3 , xPadding : 5 , showLegend : true , wholeNumbersOnly : false //true=do not show fraction in y axis , label : 'Title' }) var series1 = { title : 'apples' , x : [ 't1' , 't2' , 't3' , 't4' ], y : [ 5 , 1 , 7 , 5 ] } var series2 = { title : 'oranges' , x : [ 't1' , 't2' , 't3' , 't4' ], y : [ 2 , 1 , 4 , 8 ] } screen . append ( line ) //must append before setting data line . setData ([ series1 , series2 ]) Examples: simple line chart , multiple lines , 256 colors","title":"Line Chart"},{"location":"widgets/blessed-contrib/line-chart/#line-chart","text":"var line = contrib . line ( { style : { line : \"yellow\" , text : \"green\" , baseline : \"black\" } , xLabelPadding : 3 , xPadding : 5 , showLegend : true , wholeNumbersOnly : false //true=do not show fraction in y axis , label : 'Title' }) var series1 = { title : 'apples' , x : [ 't1' , 't2' , 't3' , 't4' ], y : [ 5 , 1 , 7 , 5 ] } var series2 = { title : 'oranges' , x : [ 't1' , 't2' , 't3' , 't4' ], y : [ 2 , 1 , 4 , 8 ] } screen . append ( line ) //must append before setting data line . setData ([ series1 , series2 ]) Examples: simple line chart , multiple lines , 256 colors","title":"Line Chart"},{"location":"widgets/blessed-contrib/map/","text":"Map \u00b6 var map = contrib . map ({ label : 'World Map' }) map . addMarker ({ \"lon\" : \"-79.0000\" , \"lat\" : \"37.5000\" , color : \"red\" , char : \"X\" })","title":"Map"},{"location":"widgets/blessed-contrib/map/#map","text":"var map = contrib . map ({ label : 'World Map' }) map . addMarker ({ \"lon\" : \"-79.0000\" , \"lat\" : \"37.5000\" , color : \"red\" , char : \"X\" })","title":"Map"},{"location":"widgets/blessed-contrib/markdown/","text":"Markdown \u00b6 var markdown = contrib . markdown () markdown . setMarkdown ( '# Hello \\n blessed-contrib renders markdown using `marked-terminal`' )","title":"Markdown"},{"location":"widgets/blessed-contrib/markdown/#markdown","text":"var markdown = contrib . markdown () markdown . setMarkdown ( '# Hello \\n blessed-contrib renders markdown using `marked-terminal`' )","title":"Markdown"},{"location":"widgets/blessed-contrib/picture/","text":"Picture \u00b6 (Also check the new blessed image implementation which has several benefits over this one.) var pic = contrib . picture ( { file : './flower.png' , cols : 25 , onReady : ready }) function ready () { screen . render ()} note: only png images are supported.","title":"Picture"},{"location":"widgets/blessed-contrib/picture/#picture","text":"(Also check the new blessed image implementation which has several benefits over this one.) var pic = contrib . picture ( { file : './flower.png' , cols : 25 , onReady : ready }) function ready () { screen . render ()} note: only png images are supported.","title":"Picture"},{"location":"widgets/blessed-contrib/rolling-log/","text":"Rolling Log \u00b6 var log = contrib . log ( { fg : \"green\" , selectedFg : \"green\" , label : 'Server Log' }) log . log ( \"new log line\" )","title":"Rolling Log"},{"location":"widgets/blessed-contrib/rolling-log/#rolling-log","text":"var log = contrib . log ( { fg : \"green\" , selectedFg : \"green\" , label : 'Server Log' }) log . log ( \"new log line\" )","title":"Rolling Log"},{"location":"widgets/blessed-contrib/sparkline/","text":"Sparkline \u00b6 var spark = contrib . sparkline ( { label : 'Throughput (bits/sec)' , tags : true , style : { fg : 'blue' }}) sparkline . setData ( [ 'Sparkline1' , 'Sparkline2' ], [ [ 10 , 20 , 30 , 20 ] , [ 40 , 10 , 40 , 50 ]])","title":"Sparkline"},{"location":"widgets/blessed-contrib/sparkline/#sparkline","text":"var spark = contrib . sparkline ( { label : 'Throughput (bits/sec)' , tags : true , style : { fg : 'blue' }}) sparkline . setData ( [ 'Sparkline1' , 'Sparkline2' ], [ [ 10 , 20 , 30 , 20 ] , [ 40 , 10 , 40 , 50 ]])","title":"Sparkline"},{"location":"widgets/blessed-contrib/stacked-bar-chart/","text":"Stacked Bar Chart \u00b6 bar = contrib . stackedBar ( { label : 'Server Utilization (%)' , barWidth : 4 , barSpacing : 6 , xOffset : 0 //, maxValue: 15 , height : \"40%\" , width : \"50%\" , barBgColor : [ 'red' , 'blue' , 'green' ]}) screen . append ( bar ) bar . setData ( { barCategory : [ 'Q1' , 'Q2' , 'Q3' , 'Q4' ] , stackedCategory : [ 'US' , 'EU' , 'AP' ] , data : [ [ 7 , 7 , 5 ] , [ 8 , 2 , 0 ] , [ 0 , 0 , 0 ] , [ 2 , 3 , 2 ] ] })","title":"Stacked Bar Chart"},{"location":"widgets/blessed-contrib/stacked-bar-chart/#stacked-bar-chart","text":"bar = contrib . stackedBar ( { label : 'Server Utilization (%)' , barWidth : 4 , barSpacing : 6 , xOffset : 0 //, maxValue: 15 , height : \"40%\" , width : \"50%\" , barBgColor : [ 'red' , 'blue' , 'green' ]}) screen . append ( bar ) bar . setData ( { barCategory : [ 'Q1' , 'Q2' , 'Q3' , 'Q4' ] , stackedCategory : [ 'US' , 'EU' , 'AP' ] , data : [ [ 7 , 7 , 5 ] , [ 8 , 2 , 0 ] , [ 0 , 0 , 0 ] , [ 2 , 3 , 2 ] ] })","title":"Stacked Bar Chart"},{"location":"widgets/blessed-contrib/stacked-gauge/","text":"Stacked Gauge \u00b6 Either specify each stacked portion with a percent and stroke ... var gauge = contrib . gauge ({ label : 'Stacked ' }) gauge . setStack ([{ percent : 30 , stroke : 'green' }, { percent : 30 , stroke : 'magenta' }, { percent : 40 , stroke : 'cyan' }]) Or, you can just supply an array of numbers and random colors will be chosen. var gauge = contrib . gauge ({ label : 'Stacked Progress' }) gauge . setStack ([ 30 , 30 , 40 ])","title":"Stacked Gauge"},{"location":"widgets/blessed-contrib/stacked-gauge/#stacked-gauge","text":"Either specify each stacked portion with a percent and stroke ... var gauge = contrib . gauge ({ label : 'Stacked ' }) gauge . setStack ([{ percent : 30 , stroke : 'green' }, { percent : 30 , stroke : 'magenta' }, { percent : 40 , stroke : 'cyan' }]) Or, you can just supply an array of numbers and random colors will be chosen. var gauge = contrib . gauge ({ label : 'Stacked Progress' }) gauge . setStack ([ 30 , 30 , 40 ])","title":"Stacked Gauge"},{"location":"widgets/blessed-contrib/table/","text":"Table \u00b6 var table = contrib . table ( { keys : true , fg : 'white' , selectedFg : 'white' , selectedBg : 'blue' , interactive : true , label : 'Active Processes' , width : '30%' , height : '30%' , border : { type : \"line\" , fg : \"cyan\" } , columnSpacing : 10 //in chars , columnWidth : [ 16 , 12 , 12 ] /*in chars*/ }) //allow control the table with the keyboard table . focus () table . setData ( { headers : [ 'col1' , 'col2' , 'col3' ] , data : [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ]})","title":"Table"},{"location":"widgets/blessed-contrib/table/#table","text":"var table = contrib . table ( { keys : true , fg : 'white' , selectedFg : 'white' , selectedBg : 'blue' , interactive : true , label : 'Active Processes' , width : '30%' , height : '30%' , border : { type : \"line\" , fg : \"cyan\" } , columnSpacing : 10 //in chars , columnWidth : [ 16 , 12 , 12 ] /*in chars*/ }) //allow control the table with the keyboard table . focus () table . setData ( { headers : [ 'col1' , 'col2' , 'col3' ] , data : [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ]})","title":"Table"},{"location":"widgets/blessed-contrib/tree/","text":"Tree \u00b6 var tree = contrib . tree ({ fg : 'green' }) //allow control the table with the keyboard tree . focus () tree . on ( 'select' , function ( node ){ if ( node . myCustomProperty ){ console . log ( node . myCustomProperty ); } console . log ( node . name ); } // you can specify a name property at root level to display root tree . setData ( { extended : true , children : { 'Fruit' : { children : { 'Banana' : {} , 'Apple' : {} , 'Cherry' : {} , 'Exotics' : { children : { 'Mango' : {} , 'Papaya' : {} , 'Kiwi' : { name : 'Kiwi (not the bird!)' , myCustomProperty : \"hairy fruit\" } }} , 'Pear' : {}}} , 'Vegetables' : { children : { 'Peas' : {} , 'Lettuce' : {} , 'Pepper' : {}}}}}) Options \u00b6 keys : Key to expand nodes. Default : ['enter','default'] extended : Should nodes be extended/generated by default? Be careful with this setting when using a callback function. Default : false template : extend : Suffix \"icon\" for closed node. Default : '[+]' retract : Suffix \"icon\" for opened node. Default : '[-]' lines : Show lines in tree. Default : true Nodes \u00b6 Every node is a hash and it can have custom properties that can be used in \"select\" event callback. However, there are several special keys : name Type : string Desc : Node name If the node isn't the root and you don't specify the name, will be set to hash key Example : { name: 'Fruit'} children Type : hash or function(node){ return children } Desc : Node children. The function must return a hash that could have been used as children property If you use a function, the result will be stored in node.childrenContent and children Example : Hash : {'Fruit':{ name: 'Fruit', children:{ 'Banana': {}, 'Cherry': {}}}} Function : see examples/explorer.js childrenContent Type : hash Desc : Children content for internal usage DO NOT MODIFY If node.children is a hash, node.children===node.childrenContent If node.children is a function, it's used to store the node.children() result You can read this property, but you should never write it. Usually this will be used to check if(node.childrenContent) in your node.children function to generate children only once extended Type : boolean Desc : Determine if this node is extended No effect when the node have no child Default value for each node will be treeInstance.options.extended if the node extended option is not set Example : {'Fruit':{ name: 'Fruit', extended: true, children:{ 'Banana': {}, 'Cherry': {}}}}","title":"Tree"},{"location":"widgets/blessed-contrib/tree/#tree","text":"var tree = contrib . tree ({ fg : 'green' }) //allow control the table with the keyboard tree . focus () tree . on ( 'select' , function ( node ){ if ( node . myCustomProperty ){ console . log ( node . myCustomProperty ); } console . log ( node . name ); } // you can specify a name property at root level to display root tree . setData ( { extended : true , children : { 'Fruit' : { children : { 'Banana' : {} , 'Apple' : {} , 'Cherry' : {} , 'Exotics' : { children : { 'Mango' : {} , 'Papaya' : {} , 'Kiwi' : { name : 'Kiwi (not the bird!)' , myCustomProperty : \"hairy fruit\" } }} , 'Pear' : {}}} , 'Vegetables' : { children : { 'Peas' : {} , 'Lettuce' : {} , 'Pepper' : {}}}}})","title":"Tree"},{"location":"widgets/blessed-contrib/tree/#options","text":"keys : Key to expand nodes. Default : ['enter','default'] extended : Should nodes be extended/generated by default? Be careful with this setting when using a callback function. Default : false template : extend : Suffix \"icon\" for closed node. Default : '[+]' retract : Suffix \"icon\" for opened node. Default : '[-]' lines : Show lines in tree. Default : true","title":"Options"},{"location":"widgets/blessed-contrib/tree/#nodes","text":"Every node is a hash and it can have custom properties that can be used in \"select\" event callback. However, there are several special keys : name Type : string Desc : Node name If the node isn't the root and you don't specify the name, will be set to hash key Example : { name: 'Fruit'} children Type : hash or function(node){ return children } Desc : Node children. The function must return a hash that could have been used as children property If you use a function, the result will be stored in node.childrenContent and children Example : Hash : {'Fruit':{ name: 'Fruit', children:{ 'Banana': {}, 'Cherry': {}}}} Function : see examples/explorer.js childrenContent Type : hash Desc : Children content for internal usage DO NOT MODIFY If node.children is a hash, node.children===node.childrenContent If node.children is a function, it's used to store the node.children() result You can read this property, but you should never write it. Usually this will be used to check if(node.childrenContent) in your node.children function to generate children only once extended Type : boolean Desc : Determine if this node is extended No effect when the node have no child Default value for each node will be treeInstance.options.extended if the node extended option is not set Example : {'Fruit':{ name: 'Fruit', extended: true, children:{ 'Banana': {}, 'Cherry': {}}}}","title":"Nodes"},{"location":"widgets/blessed-contrib/layouts/carousel/","text":"Carousel \u00b6 A carousel layout switches between different views based on time or keyboard activity. One use case is an office dashboard with rotating views: var blessed = require ( 'blessed' ) , contrib = require ( './' ) , screen = blessed . screen () function page1 ( screen ) { var map = contrib . map () screen . append ( map ) } function page2 ( screen ) { var line = contrib . line ( { width : 80 , height : 30 , left : 15 , top : 12 , xPadding : 5 , label : 'Title' }) var data = [ { title : 'us-east' , x : [ 't1' , 't2' , 't3' , 't4' ], y : [ 0 , 0.0695652173913043 , 0.11304347826087 , 2 ], style : { line : 'red' } } ] screen . append ( line ) line . setData ( data ) } screen . key ([ 'escape' , 'q' , 'C-c' ], function ( ch , key ) { return process . exit ( 0 ); }); var carousel = new contrib . carousel ( [ page1 , page2 ] , { screen : screen , interval : 3000 //how often to switch views (set 0 to never swicth automatically) , controlKeys : true //should right and left keyboard arrows control view rotation }) carousel . start ()","title":"Carousel"},{"location":"widgets/blessed-contrib/layouts/carousel/#carousel","text":"A carousel layout switches between different views based on time or keyboard activity. One use case is an office dashboard with rotating views: var blessed = require ( 'blessed' ) , contrib = require ( './' ) , screen = blessed . screen () function page1 ( screen ) { var map = contrib . map () screen . append ( map ) } function page2 ( screen ) { var line = contrib . line ( { width : 80 , height : 30 , left : 15 , top : 12 , xPadding : 5 , label : 'Title' }) var data = [ { title : 'us-east' , x : [ 't1' , 't2' , 't3' , 't4' ], y : [ 0 , 0.0695652173913043 , 0.11304347826087 , 2 ], style : { line : 'red' } } ] screen . append ( line ) line . setData ( data ) } screen . key ([ 'escape' , 'q' , 'C-c' ], function ( ch , key ) { return process . exit ( 0 ); }); var carousel = new contrib . carousel ( [ page1 , page2 ] , { screen : screen , interval : 3000 //how often to switch views (set 0 to never swicth automatically) , controlKeys : true //should right and left keyboard arrows control view rotation }) carousel . start ()","title":"Carousel"},{"location":"widgets/blessed-contrib/layouts/grid/","text":"Grid \u00b6 A grid layout can auto position your elements in a grid layout. When using a grid, you should not create the widgets, rather specify to the grid which widget to create and with which params. Each widget can span multiple rows and columns. var screen = blessed . screen () var grid = new contrib . grid ({ rows : 12 , cols : 12 , screen : screen }) //grid.set(row, col, rowSpan, colSpan, obj, opts) var map = grid . set ( 0 , 0 , 4 , 4 , contrib . map , { label : 'World Map' }) var box = grid . set ( 4 , 4 , 4 , 4 , blessed . box , { content : 'My Box' }) screen . render ()","title":"Grid"},{"location":"widgets/blessed-contrib/layouts/grid/#grid","text":"A grid layout can auto position your elements in a grid layout. When using a grid, you should not create the widgets, rather specify to the grid which widget to create and with which params. Each widget can span multiple rows and columns. var screen = blessed . screen () var grid = new contrib . grid ({ rows : 12 , cols : 12 , screen : screen }) //grid.set(row, col, rowSpan, colSpan, obj, opts) var map = grid . set ( 0 , 0 , 4 , 4 , contrib . map , { label : 'World Map' }) var box = grid . set ( 4 , 4 , 4 , 4 , blessed . box , { content : 'My Box' }) screen . render ()","title":"Grid"},{"location":"widgets/boxes/BigText/","text":"BigText (from Box) \u00b6 A box which can render content drawn as 8x14 cell characters using the terminus font. Options \u00b6 Inherits all from Box. font - bdf->json font file to use (see ttystudio for instructions on compiling BDFs to JSON). fontBold - bdf->json bold font file to use (see ttystudio for instructions on compiling BDFs to JSON). fch - foreground character. (default: ' ' ) Properties \u00b6 Inherits all from Box. Events \u00b6 Inherits all from Box. Methods \u00b6 Inherits all from Box.","title":"BigText (from Box)"},{"location":"widgets/boxes/BigText/#bigtext-from-box","text":"A box which can render content drawn as 8x14 cell characters using the terminus font.","title":"BigText (from Box)"},{"location":"widgets/boxes/BigText/#options","text":"Inherits all from Box. font - bdf->json font file to use (see ttystudio for instructions on compiling BDFs to JSON). fontBold - bdf->json bold font file to use (see ttystudio for instructions on compiling BDFs to JSON). fch - foreground character. (default: ' ' )","title":"Options"},{"location":"widgets/boxes/BigText/#properties","text":"Inherits all from Box.","title":"Properties"},{"location":"widgets/boxes/BigText/#events","text":"Inherits all from Box.","title":"Events"},{"location":"widgets/boxes/BigText/#methods","text":"Inherits all from Box.","title":"Methods"},{"location":"widgets/boxes/Box/","text":"Box (from Element) \u00b6 A box element which draws a simple box containing content or other elements. Options \u00b6 Inherits all from Element. Properties \u00b6 Inherits all from Element. Events \u00b6 Inherits all from Element. Methods \u00b6 Inherits all from Element.","title":"Box (from Element)"},{"location":"widgets/boxes/Box/#box-from-element","text":"A box element which draws a simple box containing content or other elements.","title":"Box (from Element)"},{"location":"widgets/boxes/Box/#options","text":"Inherits all from Element.","title":"Options"},{"location":"widgets/boxes/Box/#properties","text":"Inherits all from Element.","title":"Properties"},{"location":"widgets/boxes/Box/#events","text":"Inherits all from Element.","title":"Events"},{"location":"widgets/boxes/Box/#methods","text":"Inherits all from Element.","title":"Methods"},{"location":"widgets/boxes/Line/","text":"Line (from Box) \u00b6 A simple line which can be line or bg styled. Options \u00b6 Inherits all from Box. orientation - Can be vertical or horizontal . type, bg, fg, ch - Treated the same as a border object. (attributes can be contained in style ). Inherits all options, properties, events, and methods from Box.","title":"Line (from Box)"},{"location":"widgets/boxes/Line/#line-from-box","text":"A simple line which can be line or bg styled.","title":"Line (from Box)"},{"location":"widgets/boxes/Line/#options","text":"Inherits all from Box. orientation - Can be vertical or horizontal . type, bg, fg, ch - Treated the same as a border object. (attributes can be contained in style ). Inherits all options, properties, events, and methods from Box.","title":"Options"},{"location":"widgets/boxes/ScrollableBox/","text":"ScrollableBox (from Box) \u00b6 DEPRECATED - Use Box with the scrollable option instead. A box with scrollable content. Options \u00b6 Inherits all from Box. baseLimit - A limit to the childBase. Default is Infinity . alwaysScroll - A option which causes the ignoring of childOffset . This in turn causes the childBase to change every time the element is scrolled. scrollbar - Object enabling a scrollbar. scrollbar.style - Style of the scrollbar. scrollbar.track - Style of the scrollbar track if present (takes regular style options). Properties \u00b6 Inherits all from Box. childBase - The offset of the top of the scroll content. childOffset - The offset of the chosen item/line. Events \u00b6 Inherits all from Box. scroll - Received when the element is scrolled. Methods \u00b6 scroll(offset) - Scroll the content by a relative offset. scrollTo(index) - Scroll the content to an absolute index. setScroll(index) - Same as scrollTo . setScrollPerc(perc) - Set the current scroll index in percentage (0-100). getScroll() - Get the current scroll index in lines. getScrollHeight() - Get the actual height of the scrolling area. getScrollPerc() - Get the current scroll index in percentage. resetScroll() - Reset the scroll index to its initial state.","title":"ScrollableBox (from Box)"},{"location":"widgets/boxes/ScrollableBox/#scrollablebox-from-box","text":"DEPRECATED - Use Box with the scrollable option instead. A box with scrollable content.","title":"ScrollableBox (from Box)"},{"location":"widgets/boxes/ScrollableBox/#options","text":"Inherits all from Box. baseLimit - A limit to the childBase. Default is Infinity . alwaysScroll - A option which causes the ignoring of childOffset . This in turn causes the childBase to change every time the element is scrolled. scrollbar - Object enabling a scrollbar. scrollbar.style - Style of the scrollbar. scrollbar.track - Style of the scrollbar track if present (takes regular style options).","title":"Options"},{"location":"widgets/boxes/ScrollableBox/#properties","text":"Inherits all from Box. childBase - The offset of the top of the scroll content. childOffset - The offset of the chosen item/line.","title":"Properties"},{"location":"widgets/boxes/ScrollableBox/#events","text":"Inherits all from Box. scroll - Received when the element is scrolled.","title":"Events"},{"location":"widgets/boxes/ScrollableBox/#methods","text":"scroll(offset) - Scroll the content by a relative offset. scrollTo(index) - Scroll the content to an absolute index. setScroll(index) - Same as scrollTo . setScrollPerc(perc) - Set the current scroll index in percentage (0-100). getScroll() - Get the current scroll index in lines. getScrollHeight() - Get the actual height of the scrolling area. getScrollPerc() - Get the current scroll index in percentage. resetScroll() - Reset the scroll index to its initial state.","title":"Methods"},{"location":"widgets/boxes/ScrollableText/","text":"ScrollableText (from ScrollableBox) \u00b6 DEPRECATED - Use Box with the scrollable and alwaysScroll options instead. A scrollable text box which can display and scroll text, as well as handle pre-existing newlines and escape codes. Options \u00b6 Inherits all from ScrollableBox. mouse - Whether to enable automatic mouse support for this element. keys - Use predefined keys for navigating the text. vi - Use vi keys with the keys option. Properties \u00b6 Inherits all from ScrollableBox. Events \u00b6 Inherits all from ScrollableBox. Methods \u00b6 Inherits all from ScrollableBox.","title":"ScrollableText (from ScrollableBox)"},{"location":"widgets/boxes/ScrollableText/#scrollabletext-from-scrollablebox","text":"DEPRECATED - Use Box with the scrollable and alwaysScroll options instead. A scrollable text box which can display and scroll text, as well as handle pre-existing newlines and escape codes.","title":"ScrollableText (from ScrollableBox)"},{"location":"widgets/boxes/ScrollableText/#options","text":"Inherits all from ScrollableBox. mouse - Whether to enable automatic mouse support for this element. keys - Use predefined keys for navigating the text. vi - Use vi keys with the keys option.","title":"Options"},{"location":"widgets/boxes/ScrollableText/#properties","text":"Inherits all from ScrollableBox.","title":"Properties"},{"location":"widgets/boxes/ScrollableText/#events","text":"Inherits all from ScrollableBox.","title":"Events"},{"location":"widgets/boxes/ScrollableText/#methods","text":"Inherits all from ScrollableBox.","title":"Methods"},{"location":"widgets/boxes/Text/","text":"Text (from Element) \u00b6 An element similar to Box, but geared towards rendering simple text elements. Options \u00b6 Inherits all from Element. fill - Fill the entire line with chosen bg until parent bg ends, even if there is not enough text to fill the entire width. (deprecated) align - Text alignment: left , center , or right . Inherits all options, properties, events, and methods from Element.","title":"Text (from Element)"},{"location":"widgets/boxes/Text/#text-from-element","text":"An element similar to Box, but geared towards rendering simple text elements.","title":"Text (from Element)"},{"location":"widgets/boxes/Text/#options","text":"Inherits all from Element. fill - Fill the entire line with chosen bg until parent bg ends, even if there is not enough text to fill the entire width. (deprecated) align - Text alignment: left , center , or right . Inherits all options, properties, events, and methods from Element.","title":"Options"},{"location":"widgets/data-display/Log/","text":"Log (from ScrollableText) \u00b6 A log permanently scrolled to the bottom. Options \u00b6 Inherits all from ScrollableText. scrollback - Amount of scrollback allowed. Default: Infinity. scrollOnInput - Scroll to bottom on input even if the user has scrolled up. Default: false. Properties \u00b6 Inherits all from ScrollableText. scrollback - Amount of scrollback allowed. Default: Infinity. scrollOnInput - Scroll to bottom on input even if the user has scrolled up. Default: false. Events \u00b6 Inherits all from ScrollableText. log - Emitted on a log line. Passes in line. Methods \u00b6 Inherits all from ScrollableText. log/add(text) - Add a log line.","title":"Log (from ScrollableText)"},{"location":"widgets/data-display/Log/#log-from-scrollabletext","text":"A log permanently scrolled to the bottom.","title":"Log (from ScrollableText)"},{"location":"widgets/data-display/Log/#options","text":"Inherits all from ScrollableText. scrollback - Amount of scrollback allowed. Default: Infinity. scrollOnInput - Scroll to bottom on input even if the user has scrolled up. Default: false.","title":"Options"},{"location":"widgets/data-display/Log/#properties","text":"Inherits all from ScrollableText. scrollback - Amount of scrollback allowed. Default: Infinity. scrollOnInput - Scroll to bottom on input even if the user has scrolled up. Default: false.","title":"Properties"},{"location":"widgets/data-display/Log/#events","text":"Inherits all from ScrollableText. log - Emitted on a log line. Passes in line.","title":"Events"},{"location":"widgets/data-display/Log/#methods","text":"Inherits all from ScrollableText. log/add(text) - Add a log line.","title":"Methods"},{"location":"widgets/data-display/ProgressBar/","text":"ProgressBar (from Input) \u00b6 A progress bar allowing various styles. This can also be used as a form input. Options \u00b6 Inherits all from Input. orientation - Can be horizontal or vertical . style.bar - Style of the bar contents itself. pch - The character to fill the bar with (default is space). filled - The amount filled (0 - 100). value - Same as filled . keys - Enable key support. mouse - Enable mouse support. Properties \u00b6 Inherits all from Input. Events \u00b6 Inherits all from Input. reset - Bar was reset. complete - Bar has completely filled. Methods \u00b6 Inherits all from Input. progress(amount) - Progress the bar by a fill amount. setProgress(amount) - Set progress to specific amount. reset() - Reset the bar.","title":"ProgressBar (from Input)"},{"location":"widgets/data-display/ProgressBar/#progressbar-from-input","text":"A progress bar allowing various styles. This can also be used as a form input.","title":"ProgressBar (from Input)"},{"location":"widgets/data-display/ProgressBar/#options","text":"Inherits all from Input. orientation - Can be horizontal or vertical . style.bar - Style of the bar contents itself. pch - The character to fill the bar with (default is space). filled - The amount filled (0 - 100). value - Same as filled . keys - Enable key support. mouse - Enable mouse support.","title":"Options"},{"location":"widgets/data-display/ProgressBar/#properties","text":"Inherits all from Input.","title":"Properties"},{"location":"widgets/data-display/ProgressBar/#events","text":"Inherits all from Input. reset - Bar was reset. complete - Bar has completely filled.","title":"Events"},{"location":"widgets/data-display/ProgressBar/#methods","text":"Inherits all from Input. progress(amount) - Progress the bar by a fill amount. setProgress(amount) - Set progress to specific amount. reset() - Reset the bar.","title":"Methods"},{"location":"widgets/data-display/Table/","text":"Table (from Box) \u00b6 A stylized table of text elements. Options \u00b6 Inherits all from Box. rows/data - Array of array of strings representing rows. pad - Spaces to attempt to pad on the sides of each cell. 2 by default: one space on each side (only useful if the width is shrunken). noCellBorders - Do not draw inner cells. fillCellBorders - Fill cell borders with the adjacent background color. style.header - Header style. style.cell - Cell style. Properties \u00b6 Inherits all from Box. Events \u00b6 Inherits all from Box. Methods \u00b6 Inherits all from Box. setRows/setData(rows) - Set rows in table. Array of arrays of strings. table . setData ([ [ 'Animals' , 'Foods' ], [ 'Elephant' , 'Apple' ], [ 'Bird' , 'Orange' ] ]);","title":"Table (from Box)"},{"location":"widgets/data-display/Table/#table-from-box","text":"A stylized table of text elements.","title":"Table (from Box)"},{"location":"widgets/data-display/Table/#options","text":"Inherits all from Box. rows/data - Array of array of strings representing rows. pad - Spaces to attempt to pad on the sides of each cell. 2 by default: one space on each side (only useful if the width is shrunken). noCellBorders - Do not draw inner cells. fillCellBorders - Fill cell borders with the adjacent background color. style.header - Header style. style.cell - Cell style.","title":"Options"},{"location":"widgets/data-display/Table/#properties","text":"Inherits all from Box.","title":"Properties"},{"location":"widgets/data-display/Table/#events","text":"Inherits all from Box.","title":"Events"},{"location":"widgets/data-display/Table/#methods","text":"Inherits all from Box. setRows/setData(rows) - Set rows in table. Array of arrays of strings. table . setData ([ [ 'Animals' , 'Foods' ], [ 'Elephant' , 'Apple' ], [ 'Bird' , 'Orange' ] ]);","title":"Methods"},{"location":"widgets/forms/Button/","text":"Button (from Input) \u00b6 A button which can be focused and allows key and mouse input. Options \u00b6 Inherits all from Input. Properties \u00b6 Inherits all from Input. Events \u00b6 Inherits all from Input. press - Received when the button is clicked/pressed. Methods \u00b6 Inherits all from Input. press() - Press button. Emits press .","title":"Button (from Input)"},{"location":"widgets/forms/Button/#button-from-input","text":"A button which can be focused and allows key and mouse input.","title":"Button (from Input)"},{"location":"widgets/forms/Button/#options","text":"Inherits all from Input.","title":"Options"},{"location":"widgets/forms/Button/#properties","text":"Inherits all from Input.","title":"Properties"},{"location":"widgets/forms/Button/#events","text":"Inherits all from Input. press - Received when the button is clicked/pressed.","title":"Events"},{"location":"widgets/forms/Button/#methods","text":"Inherits all from Input. press() - Press button. Emits press .","title":"Methods"},{"location":"widgets/forms/Checkbox/","text":"Checkbox (from Input) \u00b6 A checkbox which can be used in a form element. Options \u00b6 Inherits all from Input. checked - Whether the element is checked or not. mouse - Enable mouse support. Properties \u00b6 Inherits all from Input. text - The text next to the checkbox (do not use setContent, use check.text = '' ). checked - Whether the element is checked or not. value - Same as checked . Events \u00b6 Inherits all from Input. check - Received when element is checked. uncheck received when element is unchecked. Methods \u00b6 Inherits all from Input. check() - Check the element. uncheck() - Uncheck the element. toggle() - Toggle checked state.","title":"Checkbox (from Input)"},{"location":"widgets/forms/Checkbox/#checkbox-from-input","text":"A checkbox which can be used in a form element.","title":"Checkbox (from Input)"},{"location":"widgets/forms/Checkbox/#options","text":"Inherits all from Input. checked - Whether the element is checked or not. mouse - Enable mouse support.","title":"Options"},{"location":"widgets/forms/Checkbox/#properties","text":"Inherits all from Input. text - The text next to the checkbox (do not use setContent, use check.text = '' ). checked - Whether the element is checked or not. value - Same as checked .","title":"Properties"},{"location":"widgets/forms/Checkbox/#events","text":"Inherits all from Input. check - Received when element is checked. uncheck received when element is unchecked.","title":"Events"},{"location":"widgets/forms/Checkbox/#methods","text":"Inherits all from Input. check() - Check the element. uncheck() - Uncheck the element. toggle() - Toggle checked state.","title":"Methods"},{"location":"widgets/forms/Form/","text":"Form (from Box) \u00b6 A form which can contain form elements. Options \u00b6 Inherits all from Box. keys - Allow default keys (tab, vi keys, enter). vi - Allow vi keys. Properties \u00b6 Inherits all from Box. submission - Last submitted data. Events \u00b6 Inherits all from Box. submit - Form is submitted. Receives a data object. cancel - Form is discarded. reset - Form is cleared. Methods \u00b6 Inherits all from Box. focusNext() - Focus next form element. focusPrevious() - Focus previous form element. submit() - Submit the form. cancel() - Discard the form. reset() - Clear the form.","title":"Form (from Box)"},{"location":"widgets/forms/Form/#form-from-box","text":"A form which can contain form elements.","title":"Form (from Box)"},{"location":"widgets/forms/Form/#options","text":"Inherits all from Box. keys - Allow default keys (tab, vi keys, enter). vi - Allow vi keys.","title":"Options"},{"location":"widgets/forms/Form/#properties","text":"Inherits all from Box. submission - Last submitted data.","title":"Properties"},{"location":"widgets/forms/Form/#events","text":"Inherits all from Box. submit - Form is submitted. Receives a data object. cancel - Form is discarded. reset - Form is cleared.","title":"Events"},{"location":"widgets/forms/Form/#methods","text":"Inherits all from Box. focusNext() - Focus next form element. focusPrevious() - Focus previous form element. submit() - Submit the form. cancel() - Discard the form. reset() - Clear the form.","title":"Methods"},{"location":"widgets/forms/Input (abstract)/","text":"Input (from Box) \u00b6 A form input.","title":"Input (from Box)"},{"location":"widgets/forms/Input (abstract)/#input-from-box","text":"A form input.","title":"Input (from Box)"},{"location":"widgets/forms/RadioButton/","text":"RadioButton (from Checkbox) \u00b6 A radio button which can be used in a form element. Options \u00b6 Inherits all from Checkbox. Properties \u00b6 Inherits all from Checkbox. Events \u00b6 Inherits all from Checkbox. Methods \u00b6 Inherits all from Checkbox.","title":"RadioButton (from Checkbox)"},{"location":"widgets/forms/RadioButton/#radiobutton-from-checkbox","text":"A radio button which can be used in a form element.","title":"RadioButton (from Checkbox)"},{"location":"widgets/forms/RadioButton/#options","text":"Inherits all from Checkbox.","title":"Options"},{"location":"widgets/forms/RadioButton/#properties","text":"Inherits all from Checkbox.","title":"Properties"},{"location":"widgets/forms/RadioButton/#events","text":"Inherits all from Checkbox.","title":"Events"},{"location":"widgets/forms/RadioButton/#methods","text":"Inherits all from Checkbox.","title":"Methods"},{"location":"widgets/forms/RadioSet/","text":"RadioSet (from Box) \u00b6 An element wrapping RadioButtons. RadioButtons within this element will be mutually exclusive with each other. Options \u00b6 Inherits all from Box. Properties \u00b6 Inherits all from Box. Events \u00b6 Inherits all from Box. Methods \u00b6 Inherits all from Box.","title":"RadioSet (from Box)"},{"location":"widgets/forms/RadioSet/#radioset-from-box","text":"An element wrapping RadioButtons. RadioButtons within this element will be mutually exclusive with each other.","title":"RadioSet (from Box)"},{"location":"widgets/forms/RadioSet/#options","text":"Inherits all from Box.","title":"Options"},{"location":"widgets/forms/RadioSet/#properties","text":"Inherits all from Box.","title":"Properties"},{"location":"widgets/forms/RadioSet/#events","text":"Inherits all from Box.","title":"Events"},{"location":"widgets/forms/RadioSet/#methods","text":"Inherits all from Box.","title":"Methods"},{"location":"widgets/forms/TextArea/","text":"Textarea (from Input) \u00b6 A box which allows multiline text input. Options \u00b6 Inherits all from Input. keys - Use pre-defined keys ( i or enter for insert, e for editor, C-e for editor while inserting). mouse - Use pre-defined mouse events (right-click for editor). inputOnFocus - Call readInput() when the element is focused. Automatically unfocus. Properties \u00b6 Inherits all from Input. value - The input text. read-only . Events \u00b6 Inherits all from Input. submit - Value is submitted (enter). cancel - Value is discared (escape). action - Either submit or cancel. Methods \u00b6 Inherits all from Input. submit - Submit the textarea (emits submit ). cancel - Cancel the textarea (emits cancel ). readInput(callback) - Grab key events and start reading text from the keyboard. Takes a callback which receives the final value. readEditor(callback) - Open text editor in $EDITOR , read the output from the resulting file. Takes a callback which receives the final value. getValue() - The same as this.value , for now. clearValue() - Clear input. setValue(text) - Set value.","title":"Textarea (from Input)"},{"location":"widgets/forms/TextArea/#textarea-from-input","text":"A box which allows multiline text input.","title":"Textarea (from Input)"},{"location":"widgets/forms/TextArea/#options","text":"Inherits all from Input. keys - Use pre-defined keys ( i or enter for insert, e for editor, C-e for editor while inserting). mouse - Use pre-defined mouse events (right-click for editor). inputOnFocus - Call readInput() when the element is focused. Automatically unfocus.","title":"Options"},{"location":"widgets/forms/TextArea/#properties","text":"Inherits all from Input. value - The input text. read-only .","title":"Properties"},{"location":"widgets/forms/TextArea/#events","text":"Inherits all from Input. submit - Value is submitted (enter). cancel - Value is discared (escape). action - Either submit or cancel.","title":"Events"},{"location":"widgets/forms/TextArea/#methods","text":"Inherits all from Input. submit - Submit the textarea (emits submit ). cancel - Cancel the textarea (emits cancel ). readInput(callback) - Grab key events and start reading text from the keyboard. Takes a callback which receives the final value. readEditor(callback) - Open text editor in $EDITOR , read the output from the resulting file. Takes a callback which receives the final value. getValue() - The same as this.value , for now. clearValue() - Clear input. setValue(text) - Set value.","title":"Methods"},{"location":"widgets/forms/Textbox/","text":"Textbox (from Textarea) \u00b6 A box which allows text input. Options \u00b6 Inherits all from Textarea. secret - Completely hide text. censor - Replace text with asterisks ( * ). Properties \u00b6 Inherits all from Textarea. secret - Completely hide text. censor - Replace text with asterisks ( * ). Events \u00b6 Inherits all from Textarea. Methods \u00b6 Inherits all from Textarea.","title":"Textbox (from Textarea)"},{"location":"widgets/forms/Textbox/#textbox-from-textarea","text":"A box which allows text input.","title":"Textbox (from Textarea)"},{"location":"widgets/forms/Textbox/#options","text":"Inherits all from Textarea. secret - Completely hide text. censor - Replace text with asterisks ( * ).","title":"Options"},{"location":"widgets/forms/Textbox/#properties","text":"Inherits all from Textarea. secret - Completely hide text. censor - Replace text with asterisks ( * ).","title":"Properties"},{"location":"widgets/forms/Textbox/#events","text":"Inherits all from Textarea.","title":"Events"},{"location":"widgets/forms/Textbox/#methods","text":"Inherits all from Textarea.","title":"Methods"},{"location":"widgets/lists/FileManager/","text":"FileManager (from List) \u00b6 A very simple file manager for selecting files. Options \u00b6 Inherits all from List. cwd - Current working directory. Properties \u00b6 Inherits all from List. cwd - Current working directory. Events \u00b6 Inherits all from List. cd - Directory was selected and navigated to. file - File was selected. Methods \u00b6 Inherits all from List. refresh([cwd], [callback]) - Refresh the file list (perform a readdir on cwd and update the list items). pick([cwd], callback) - Pick a single file and return the path in the callback. reset([cwd], [callback]) - Reset back to original cwd.","title":"FileManager (from List)"},{"location":"widgets/lists/FileManager/#filemanager-from-list","text":"A very simple file manager for selecting files.","title":"FileManager (from List)"},{"location":"widgets/lists/FileManager/#options","text":"Inherits all from List. cwd - Current working directory.","title":"Options"},{"location":"widgets/lists/FileManager/#properties","text":"Inherits all from List. cwd - Current working directory.","title":"Properties"},{"location":"widgets/lists/FileManager/#events","text":"Inherits all from List. cd - Directory was selected and navigated to. file - File was selected.","title":"Events"},{"location":"widgets/lists/FileManager/#methods","text":"Inherits all from List. refresh([cwd], [callback]) - Refresh the file list (perform a readdir on cwd and update the list items). pick([cwd], callback) - Pick a single file and return the path in the callback. reset([cwd], [callback]) - Reset back to original cwd.","title":"Methods"},{"location":"widgets/lists/List/","text":"List (from Box) \u00b6 A scrollable list which can display selectable items. Options \u00b6 Inherits all from Box. style.selected - Style for a selected item. style.item - Style for an unselected item. mouse - Whether to automatically enable mouse support for this list (allows clicking items). keys - Use predefined keys for navigating the list. vi - Use vi keys with the keys option. items - An array of strings which become the list's items. search - A function that is called when vi mode is enabled and the key / is pressed. This function accepts a callback function which should be called with the search string. The search string is then used to jump to an item that is found in items . interactive - Whether the list is interactive and can have items selected (Default: true). invertSelected - Whether to automatically override tags and invert fg of item when selected (Default: true ). Properties \u00b6 Inherits all from Box. Events \u00b6 Inherits all from Box. select - Received when an item is selected. cancel - List was canceled (when esc is pressed with the keys option). action - Either a select or a cancel event was received. Methods \u00b6 Inherits all from Box. add/addItem(text) - Add an item based on a string. removeItem(child) - Removes an item from the list. Child can be an element, index, or string. pushItem(child) - Push an item onto the list. popItem() - Pop an item off the list. unshiftItem(child) - Unshift an item onto the list. shiftItem() - Shift an item off the list. insertItem(i, child) - Inserts an item to the list. Child can be an element, index, or string. getItem(child) - Returns the item element. Child can be an element, index, or string. setItem(child, content) - Set item to content. spliceItem(i, n, item1, ...) - Remove and insert items to the list. clearItems() - Clears all items from the list. setItems(items) - Sets the list items to multiple strings. getItemIndex(child) - Returns the item index from the list. Child can be an element, index, or string. select(index) - Select an index of an item. move(offset) - Select item based on current offset. up(amount) - Select item above selected. down(amount) - Select item below selected. pick(callback) - Show/focus list and pick an item. The callback is executed with the result. fuzzyFind([string/regex/callback]) - Find an item based on its text content.","title":"List (from Box)"},{"location":"widgets/lists/List/#list-from-box","text":"A scrollable list which can display selectable items.","title":"List (from Box)"},{"location":"widgets/lists/List/#options","text":"Inherits all from Box. style.selected - Style for a selected item. style.item - Style for an unselected item. mouse - Whether to automatically enable mouse support for this list (allows clicking items). keys - Use predefined keys for navigating the list. vi - Use vi keys with the keys option. items - An array of strings which become the list's items. search - A function that is called when vi mode is enabled and the key / is pressed. This function accepts a callback function which should be called with the search string. The search string is then used to jump to an item that is found in items . interactive - Whether the list is interactive and can have items selected (Default: true). invertSelected - Whether to automatically override tags and invert fg of item when selected (Default: true ).","title":"Options"},{"location":"widgets/lists/List/#properties","text":"Inherits all from Box.","title":"Properties"},{"location":"widgets/lists/List/#events","text":"Inherits all from Box. select - Received when an item is selected. cancel - List was canceled (when esc is pressed with the keys option). action - Either a select or a cancel event was received.","title":"Events"},{"location":"widgets/lists/List/#methods","text":"Inherits all from Box. add/addItem(text) - Add an item based on a string. removeItem(child) - Removes an item from the list. Child can be an element, index, or string. pushItem(child) - Push an item onto the list. popItem() - Pop an item off the list. unshiftItem(child) - Unshift an item onto the list. shiftItem() - Shift an item off the list. insertItem(i, child) - Inserts an item to the list. Child can be an element, index, or string. getItem(child) - Returns the item element. Child can be an element, index, or string. setItem(child, content) - Set item to content. spliceItem(i, n, item1, ...) - Remove and insert items to the list. clearItems() - Clears all items from the list. setItems(items) - Sets the list items to multiple strings. getItemIndex(child) - Returns the item index from the list. Child can be an element, index, or string. select(index) - Select an index of an item. move(offset) - Select item based on current offset. up(amount) - Select item above selected. down(amount) - Select item below selected. pick(callback) - Show/focus list and pick an item. The callback is executed with the result. fuzzyFind([string/regex/callback]) - Find an item based on its text content.","title":"Methods"},{"location":"widgets/lists/ListTable/","text":"ListTable (from List) \u00b6 A stylized table of text elements with a list. Options \u00b6 Inherits all from List. rows/data - Array of array of strings representing rows. pad - Spaces to attempt to pad on the sides of each cell. 2 by default: one space on each side (only useful if the width is shrunken). noCellBorders - Do not draw inner cells. style.header - Header style. style.cell - Cell style. Properties \u00b6 Inherits all from List. Events \u00b6 Inherits all from List. Methods \u00b6 Inherits all from List. setRows/setData(rows) - Set rows in table. Array of arrays of strings. table . setData ([ [ 'Animals' , 'Foods' ], [ 'Elephant' , 'Apple' ], [ 'Bird' , 'Orange' ] ]);","title":"ListTable (from List)"},{"location":"widgets/lists/ListTable/#listtable-from-list","text":"A stylized table of text elements with a list.","title":"ListTable (from List)"},{"location":"widgets/lists/ListTable/#options","text":"Inherits all from List. rows/data - Array of array of strings representing rows. pad - Spaces to attempt to pad on the sides of each cell. 2 by default: one space on each side (only useful if the width is shrunken). noCellBorders - Do not draw inner cells. style.header - Header style. style.cell - Cell style.","title":"Options"},{"location":"widgets/lists/ListTable/#properties","text":"Inherits all from List.","title":"Properties"},{"location":"widgets/lists/ListTable/#events","text":"Inherits all from List.","title":"Events"},{"location":"widgets/lists/ListTable/#methods","text":"Inherits all from List. setRows/setData(rows) - Set rows in table. Array of arrays of strings. table . setData ([ [ 'Animals' , 'Foods' ], [ 'Elephant' , 'Apple' ], [ 'Bird' , 'Orange' ] ]);","title":"Methods"},{"location":"widgets/lists/Listbar/","text":"Listbar (from Box) \u00b6 A horizontal list. Useful for a main menu bar. Options \u00b6 Inherits all from Box. style.selected - Style for a selected item. style.item - Style for an unselected item. commands/items - Set buttons using an object with keys as titles of buttons, containing of objects containing keys of keys and callback . autoCommandKeys - Automatically bind list buttons to keys 0-9. Properties \u00b6 Inherits all from Box. Events \u00b6 Inherits all from Box. Methods \u00b6 Inherits all from Box. setItems(commands) - Set commands (see commands option above). add/addItem/appendItem(item, callback) - Append an item to the bar. select(offset) - Select an item on the bar. removeItem(child) - Remove item from the bar. move(offset) - Move relatively across the bar. moveLeft(offset) - Move left relatively across the bar. moveRight(offset) - Move right relatively across the bar. selectTab(index) - Select button and execute its callback.","title":"Listbar (from Box)"},{"location":"widgets/lists/Listbar/#listbar-from-box","text":"A horizontal list. Useful for a main menu bar.","title":"Listbar (from Box)"},{"location":"widgets/lists/Listbar/#options","text":"Inherits all from Box. style.selected - Style for a selected item. style.item - Style for an unselected item. commands/items - Set buttons using an object with keys as titles of buttons, containing of objects containing keys of keys and callback . autoCommandKeys - Automatically bind list buttons to keys 0-9.","title":"Options"},{"location":"widgets/lists/Listbar/#properties","text":"Inherits all from Box.","title":"Properties"},{"location":"widgets/lists/Listbar/#events","text":"Inherits all from Box.","title":"Events"},{"location":"widgets/lists/Listbar/#methods","text":"Inherits all from Box. setItems(commands) - Set commands (see commands option above). add/addItem/appendItem(item, callback) - Append an item to the bar. select(offset) - Select an item on the bar. removeItem(child) - Remove item from the bar. move(offset) - Move relatively across the bar. moveLeft(offset) - Move left relatively across the bar. moveRight(offset) - Move right relatively across the bar. selectTab(index) - Select button and execute its callback.","title":"Methods"},{"location":"widgets/prompts/Loading/","text":"Loading (from Box) \u00b6 A box with a spinning line to denote loading (automatically hidden). Options \u00b6 Inherits all from Box. Properties \u00b6 Inherits all from Box. Events \u00b6 Inherits all from Box. Methods \u00b6 Inherits all from Box. load(text) - Display the loading box with a message. Will lock keys until stop is called. stop() - Hide loading box. Unlock keys.","title":"Loading (from Box)"},{"location":"widgets/prompts/Loading/#loading-from-box","text":"A box with a spinning line to denote loading (automatically hidden).","title":"Loading (from Box)"},{"location":"widgets/prompts/Loading/#options","text":"Inherits all from Box.","title":"Options"},{"location":"widgets/prompts/Loading/#properties","text":"Inherits all from Box.","title":"Properties"},{"location":"widgets/prompts/Loading/#events","text":"Inherits all from Box.","title":"Events"},{"location":"widgets/prompts/Loading/#methods","text":"Inherits all from Box. load(text) - Display the loading box with a message. Will lock keys until stop is called. stop() - Hide loading box. Unlock keys.","title":"Methods"},{"location":"widgets/prompts/Message/","text":"Message (from Box) \u00b6 A box containing a message to be displayed (automatically hidden). Options \u00b6 Inherits all from Box. Properties \u00b6 Inherits all from Box. Events \u00b6 Inherits all from Box. Methods \u00b6 Inherits all from Box. log/display(text, [time], callback) - Display a message for a time (default is 3 seconds). Set time to 0 for a perpetual message that is dismissed on keypress. error(text, [time], callback) - Display an error in the same way.","title":"Message (from Box)"},{"location":"widgets/prompts/Message/#message-from-box","text":"A box containing a message to be displayed (automatically hidden).","title":"Message (from Box)"},{"location":"widgets/prompts/Message/#options","text":"Inherits all from Box.","title":"Options"},{"location":"widgets/prompts/Message/#properties","text":"Inherits all from Box.","title":"Properties"},{"location":"widgets/prompts/Message/#events","text":"Inherits all from Box.","title":"Events"},{"location":"widgets/prompts/Message/#methods","text":"Inherits all from Box. log/display(text, [time], callback) - Display a message for a time (default is 3 seconds). Set time to 0 for a perpetual message that is dismissed on keypress. error(text, [time], callback) - Display an error in the same way.","title":"Methods"},{"location":"widgets/prompts/Prompt/","text":"Prompt (from Box) \u00b6 A prompt box containing a text input, okay, and cancel buttons (automatically hidden). Options \u00b6 Inherits all from Box. Properties \u00b6 Inherits all from Box. Events \u00b6 Inherits all from Box. Methods \u00b6 Inherits all from Box. input/setInput/readInput(text, value, callback) - Show the prompt and wait for the result of the textbox. Set text and initial value.","title":"Prompt (from Box)"},{"location":"widgets/prompts/Prompt/#prompt-from-box","text":"A prompt box containing a text input, okay, and cancel buttons (automatically hidden).","title":"Prompt (from Box)"},{"location":"widgets/prompts/Prompt/#options","text":"Inherits all from Box.","title":"Options"},{"location":"widgets/prompts/Prompt/#properties","text":"Inherits all from Box.","title":"Properties"},{"location":"widgets/prompts/Prompt/#events","text":"Inherits all from Box.","title":"Events"},{"location":"widgets/prompts/Prompt/#methods","text":"Inherits all from Box. input/setInput/readInput(text, value, callback) - Show the prompt and wait for the result of the textbox. Set text and initial value.","title":"Methods"},{"location":"widgets/prompts/Question/","text":"Question (from Box) \u00b6 A question box containing okay and cancel buttons (automatically hidden). Options \u00b6 Inherits all from Box. Properties \u00b6 Inherits all from Box. Events \u00b6 Inherits all from Box. Methods \u00b6 Inherits all from Box. ask(question, callback) - Ask a question . callback will yield the result.","title":"Question (from Box)"},{"location":"widgets/prompts/Question/#question-from-box","text":"A question box containing okay and cancel buttons (automatically hidden).","title":"Question (from Box)"},{"location":"widgets/prompts/Question/#options","text":"Inherits all from Box.","title":"Options"},{"location":"widgets/prompts/Question/#properties","text":"Inherits all from Box.","title":"Properties"},{"location":"widgets/prompts/Question/#events","text":"Inherits all from Box.","title":"Events"},{"location":"widgets/prompts/Question/#methods","text":"Inherits all from Box. ask(question, callback) - Ask a question . callback will yield the result.","title":"Methods"},{"location":"widgets/special-elements/ANSIImage/","text":"ANSIImage (from Box) \u00b6 Convert any .png file (or .gif , see below) to an ANSI image and display it as an element. This differs from the OverlayImage element in that it uses blessed's internal PNG/GIF parser and does not require external dependencies. Blessed uses an internal from-scratch PNG/GIF reader because no other javascript PNG reader supports Adam7 interlaced images (much less pass the png test suite). The blessed PNG reader supports adam7 deinterlacing, animation (APNG), all color types, bit depths 1-32, alpha, alpha palettes, and outputs scaled bitmaps (cellmaps) in blessed for efficient rendering to the screen buffer. It also uses some code from libcaca/libcucul to add density ASCII characters in order to give the image more detail in the terminal. If a corrupt PNG or a non-PNG is passed in, blessed will display error text in the element. .gif files are also supported via a javascript implementation (they are internally converted to bitmaps and fed to the PNG renderer). Any other image format is support only if the user has imagemagick ( convert and identify ) installed. Options \u00b6 Inherits all from Box. file - URL or path to PNG/GIF file. Can also be a buffer. scale - Scale cellmap down ( 0-1.0 ) from its original pixel width/height (Default: 1.0 ). width/height - This differs from other element's width or height in that only one of them is needed: blessed will maintain the aspect ratio of the image as it scales down to the proper number of cells. NOTE : PNG/GIF's are always automatically shrunken to size (based on scale) if a width or height is not given. ascii - Add various \"density\" ASCII characters over the rendering to give the image more detail, similar to libcaca/libcucul (the library mplayer uses to display videos in the terminal). animate - Whether to animate if the image is an APNG/animating GIF. If false, only display the first frame or IDAT (Default: true ). speed - Set the speed of animation. Slower: 0.0-1.0 . Faster: 1-1000 . It cannot go faster than 1 frame per millisecond, so 1000 is the fastest. (Default: 1.0) optimization - mem or cpu . If optimizing for memory, animation frames will be rendered to bitmaps as the animation plays , using less memory. Optimizing for cpu will precompile all bitmaps beforehand, which may be faster, but might also OOM the process on large images. (Default: mem ). Properties \u00b6 Inherits all from Box. img - Image object from the png reader. img.width - Pixel width. img.height - Pixel height. img.bmp - Image bitmap. img.cellmap - Image cellmap (bitmap scaled down to cell size). Events \u00b6 Inherits all from Box. Methods \u00b6 Inherits all from Box. setImage(file) - Set the image in the box to a new path. File can be a path, url, or buffer. clearImage() - Clear the image. play() - Play animation if it has been paused or stopped. pause() - Pause animation. stop() - Stop animation.","title":"ANSIImage (from Box)"},{"location":"widgets/special-elements/ANSIImage/#ansiimage-from-box","text":"Convert any .png file (or .gif , see below) to an ANSI image and display it as an element. This differs from the OverlayImage element in that it uses blessed's internal PNG/GIF parser and does not require external dependencies. Blessed uses an internal from-scratch PNG/GIF reader because no other javascript PNG reader supports Adam7 interlaced images (much less pass the png test suite). The blessed PNG reader supports adam7 deinterlacing, animation (APNG), all color types, bit depths 1-32, alpha, alpha palettes, and outputs scaled bitmaps (cellmaps) in blessed for efficient rendering to the screen buffer. It also uses some code from libcaca/libcucul to add density ASCII characters in order to give the image more detail in the terminal. If a corrupt PNG or a non-PNG is passed in, blessed will display error text in the element. .gif files are also supported via a javascript implementation (they are internally converted to bitmaps and fed to the PNG renderer). Any other image format is support only if the user has imagemagick ( convert and identify ) installed.","title":"ANSIImage (from Box)"},{"location":"widgets/special-elements/ANSIImage/#options","text":"Inherits all from Box. file - URL or path to PNG/GIF file. Can also be a buffer. scale - Scale cellmap down ( 0-1.0 ) from its original pixel width/height (Default: 1.0 ). width/height - This differs from other element's width or height in that only one of them is needed: blessed will maintain the aspect ratio of the image as it scales down to the proper number of cells. NOTE : PNG/GIF's are always automatically shrunken to size (based on scale) if a width or height is not given. ascii - Add various \"density\" ASCII characters over the rendering to give the image more detail, similar to libcaca/libcucul (the library mplayer uses to display videos in the terminal). animate - Whether to animate if the image is an APNG/animating GIF. If false, only display the first frame or IDAT (Default: true ). speed - Set the speed of animation. Slower: 0.0-1.0 . Faster: 1-1000 . It cannot go faster than 1 frame per millisecond, so 1000 is the fastest. (Default: 1.0) optimization - mem or cpu . If optimizing for memory, animation frames will be rendered to bitmaps as the animation plays , using less memory. Optimizing for cpu will precompile all bitmaps beforehand, which may be faster, but might also OOM the process on large images. (Default: mem ).","title":"Options"},{"location":"widgets/special-elements/ANSIImage/#properties","text":"Inherits all from Box. img - Image object from the png reader. img.width - Pixel width. img.height - Pixel height. img.bmp - Image bitmap. img.cellmap - Image cellmap (bitmap scaled down to cell size).","title":"Properties"},{"location":"widgets/special-elements/ANSIImage/#events","text":"Inherits all from Box.","title":"Events"},{"location":"widgets/special-elements/ANSIImage/#methods","text":"Inherits all from Box. setImage(file) - Set the image in the box to a new path. File can be a path, url, or buffer. clearImage() - Clear the image. play() - Play animation if it has been paused or stopped. pause() - Pause animation. stop() - Stop animation.","title":"Methods"},{"location":"widgets/special-elements/Image/","text":"Image (from Box) \u00b6 Display an image in the terminal (jpeg, png, gif) using either blessed's internal png/gif-to-terminal renderer (using a ANSIImage element ) or using w3mimgdisplay (using a OverlayImage element ). Options \u00b6 Inherits all from Box. file - Path to image. type - ansi or overlay . Whether to render the file as ANSI art or using w3m to overlay. See the ANSIImage element for more information/options. ( default : ansi ). Properties \u00b6 Inherits all from Box. See ANSIImage element See OverlayImage element Events \u00b6 Inherits all from Box. See ANSIImage element See OverlayImage element Methods \u00b6 Inherits all from Box. See ANSIImage element See OverlayImage element","title":"Image (from Box)"},{"location":"widgets/special-elements/Image/#image-from-box","text":"Display an image in the terminal (jpeg, png, gif) using either blessed's internal png/gif-to-terminal renderer (using a ANSIImage element ) or using w3mimgdisplay (using a OverlayImage element ).","title":"Image (from Box)"},{"location":"widgets/special-elements/Image/#options","text":"Inherits all from Box. file - Path to image. type - ansi or overlay . Whether to render the file as ANSI art or using w3m to overlay. See the ANSIImage element for more information/options. ( default : ansi ).","title":"Options"},{"location":"widgets/special-elements/Image/#properties","text":"Inherits all from Box. See ANSIImage element See OverlayImage element","title":"Properties"},{"location":"widgets/special-elements/Image/#events","text":"Inherits all from Box. See ANSIImage element See OverlayImage element","title":"Events"},{"location":"widgets/special-elements/Image/#methods","text":"Inherits all from Box. See ANSIImage element See OverlayImage element","title":"Methods"},{"location":"widgets/special-elements/Layout/","text":"Layout (from Element) \u00b6 A layout which can position children automatically based on a renderer method ( experimental - the mechanics of this element may be changed in the future!). By default, the Layout element automatically positions children as if they were display : inline - block ; in CSS. Options \u00b6 Inherits all from Element. renderer - A callback which is called right before the children are iterated over to be rendered. Should return an iterator callback which is called on each child element: iterator(el, i) . layout - Using the default renderer, it provides two layouts: inline, and grid. inline is the default and will render akin to inline-block . grid will create an automatic grid based on element dimensions. The grid cells' width and height are always determined by the largest children in the layout. Properties \u00b6 Inherits all from Element. Events \u00b6 Inherits all from Element. Methods \u00b6 Inherits all from Element. renderer(coords) - A callback which is called right before the children are iterated over to be rendered. Should return an iterator callback which is called on each child element: iterator(el, i) . isRendered(el) - Check to see if a previous child element has been rendered and is visible on screen. This is only useful for checking child elements that have already been attempted to be rendered! see the example below. getLast(i) - Get the last rendered and visible child element based on an index. This is useful for basing the position of the current child element on the position of the last child element. getLastCoords(i) - Get the last rendered and visible child element coords based on an index. This is useful for basing the position of the current child element on the position of the last child element. See the example below. Rendering a Layout for child elements \u00b6 Notes \u00b6 You must always give Layout a width and height. This is a chicken-and-egg problem: blessed cannot calculate the width and height dynamically before the children are positioned. border and padding are already calculated into the coords object the renderer receives, so there is no need to account for it in your renderer. Try to set position for children using el.position . el.position is the most primitive \"to-be-rendered\" way to set coordinates. Setting el.left directly has more dynamic behavior which may interfere with rendering. Some definitions for coords (otherwise known as el.lpos ): coords.xi - the absolute x coordinate of the left side of a rendered element. It is absolute: relative to the screen itself. coords.xl - the absolute x coordinate of the right side of a rendered element. It is absolute: relative to the screen itself. coords.yi - the absolute y coordinate of the top side of a rendered element. It is absolute: relative to the screen itself. coords.yl - the absolute y coordinate of the bottom side of a rendered element. It is absolute: relative to the screen itself. Note again: the coords the renderer receives for the Layout already has border and padding subtracted, so you do not have to account for these. The children do not. Example \u00b6 Here is an example of how to provide a renderer. Note that this is also the default renderer if none is provided. This renderer will render each child as though they were display : inline - block ; in CSS, as if there were a dynamically sized horizontal grid from left to right. var layout = blessed . layout ({ parent : screen , top : 'center' , left : 'center' , width : '50%' , height : '50%' , border : 'line' , style : { bg : 'red' , border : { fg : 'blue' } }, // NOTE: This is already the default renderer if none is provided! renderer : function ( coords ) { var self = this ; // The coordinates of the layout element var width = coords . xl - coords . xi , height = coords . yl - coords . yi , xi = coords . xi , xl = coords . xl , yi = coords . yi , yl = coords . yl ; // The current row offset in cells (which row are we on?) var rowOffset = 0 ; // The index of the first child in the row var rowIndex = 0 ; return function iterator ( el , i ) { // Make our children shrinkable. If they don't have a height, for // example, calculate it for them. el . shrink = true ; // Find the previous rendered child's coordinates var last = self . getLastCoords ( i ); // If there is no previously rendered element, we are on the first child. if ( ! last ) { el . position . left = 0 ; el . position . top = 0 ; } else { // Otherwise, figure out where to place this child. We'll start by // setting it's `left`/`x` coordinate to right after the previous // rendered element. This child will end up directly to the right of it. el . position . left = last . xl - xi ; // If our child does not overlap the right side of the Layout, set it's // `top`/`y` to the current `rowOffset` (the coordinate for the current // row). if ( el . position . left + el . width <= width ) { el . position . top = rowOffset ; } else { // Otherwise we need to start a new row and calculate a new // `rowOffset` and `rowIndex` (the index of the child on the current // row). rowOffset += self . children . slice ( rowIndex , i ). reduce ( function ( out , el ) { if ( ! self . isRendered ( el )) return out ; out = Math . max ( out , el . lpos . yl - el . lpos . yi ); return out ; }, 0 ); rowIndex = i ; el . position . left = 0 ; el . position . top = rowOffset ; } } // If our child overflows the Layout, do not render it! // Disable this feature for now. if ( el . position . top + el . height > height ) { // Returning false tells blessed to ignore this child. // return false; } }; } }); for ( var i = 0 ; i < 10 ; i ++ ) { blessed . box ({ parent : layout , width : i % 2 === 0 ? 10 : 20 , height : i % 2 === 0 ? 5 : 10 , border : 'line' }); }","title":"Layout (from Element)"},{"location":"widgets/special-elements/Layout/#layout-from-element","text":"A layout which can position children automatically based on a renderer method ( experimental - the mechanics of this element may be changed in the future!). By default, the Layout element automatically positions children as if they were display : inline - block ; in CSS.","title":"Layout (from Element)"},{"location":"widgets/special-elements/Layout/#options","text":"Inherits all from Element. renderer - A callback which is called right before the children are iterated over to be rendered. Should return an iterator callback which is called on each child element: iterator(el, i) . layout - Using the default renderer, it provides two layouts: inline, and grid. inline is the default and will render akin to inline-block . grid will create an automatic grid based on element dimensions. The grid cells' width and height are always determined by the largest children in the layout.","title":"Options"},{"location":"widgets/special-elements/Layout/#properties","text":"Inherits all from Element.","title":"Properties"},{"location":"widgets/special-elements/Layout/#events","text":"Inherits all from Element.","title":"Events"},{"location":"widgets/special-elements/Layout/#methods","text":"Inherits all from Element. renderer(coords) - A callback which is called right before the children are iterated over to be rendered. Should return an iterator callback which is called on each child element: iterator(el, i) . isRendered(el) - Check to see if a previous child element has been rendered and is visible on screen. This is only useful for checking child elements that have already been attempted to be rendered! see the example below. getLast(i) - Get the last rendered and visible child element based on an index. This is useful for basing the position of the current child element on the position of the last child element. getLastCoords(i) - Get the last rendered and visible child element coords based on an index. This is useful for basing the position of the current child element on the position of the last child element. See the example below.","title":"Methods"},{"location":"widgets/special-elements/Layout/#rendering-a-layout-for-child-elements","text":"","title":"Rendering a Layout for child elements"},{"location":"widgets/special-elements/Layout/#notes","text":"You must always give Layout a width and height. This is a chicken-and-egg problem: blessed cannot calculate the width and height dynamically before the children are positioned. border and padding are already calculated into the coords object the renderer receives, so there is no need to account for it in your renderer. Try to set position for children using el.position . el.position is the most primitive \"to-be-rendered\" way to set coordinates. Setting el.left directly has more dynamic behavior which may interfere with rendering. Some definitions for coords (otherwise known as el.lpos ): coords.xi - the absolute x coordinate of the left side of a rendered element. It is absolute: relative to the screen itself. coords.xl - the absolute x coordinate of the right side of a rendered element. It is absolute: relative to the screen itself. coords.yi - the absolute y coordinate of the top side of a rendered element. It is absolute: relative to the screen itself. coords.yl - the absolute y coordinate of the bottom side of a rendered element. It is absolute: relative to the screen itself. Note again: the coords the renderer receives for the Layout already has border and padding subtracted, so you do not have to account for these. The children do not.","title":"Notes"},{"location":"widgets/special-elements/Layout/#example","text":"Here is an example of how to provide a renderer. Note that this is also the default renderer if none is provided. This renderer will render each child as though they were display : inline - block ; in CSS, as if there were a dynamically sized horizontal grid from left to right. var layout = blessed . layout ({ parent : screen , top : 'center' , left : 'center' , width : '50%' , height : '50%' , border : 'line' , style : { bg : 'red' , border : { fg : 'blue' } }, // NOTE: This is already the default renderer if none is provided! renderer : function ( coords ) { var self = this ; // The coordinates of the layout element var width = coords . xl - coords . xi , height = coords . yl - coords . yi , xi = coords . xi , xl = coords . xl , yi = coords . yi , yl = coords . yl ; // The current row offset in cells (which row are we on?) var rowOffset = 0 ; // The index of the first child in the row var rowIndex = 0 ; return function iterator ( el , i ) { // Make our children shrinkable. If they don't have a height, for // example, calculate it for them. el . shrink = true ; // Find the previous rendered child's coordinates var last = self . getLastCoords ( i ); // If there is no previously rendered element, we are on the first child. if ( ! last ) { el . position . left = 0 ; el . position . top = 0 ; } else { // Otherwise, figure out where to place this child. We'll start by // setting it's `left`/`x` coordinate to right after the previous // rendered element. This child will end up directly to the right of it. el . position . left = last . xl - xi ; // If our child does not overlap the right side of the Layout, set it's // `top`/`y` to the current `rowOffset` (the coordinate for the current // row). if ( el . position . left + el . width <= width ) { el . position . top = rowOffset ; } else { // Otherwise we need to start a new row and calculate a new // `rowOffset` and `rowIndex` (the index of the child on the current // row). rowOffset += self . children . slice ( rowIndex , i ). reduce ( function ( out , el ) { if ( ! self . isRendered ( el )) return out ; out = Math . max ( out , el . lpos . yl - el . lpos . yi ); return out ; }, 0 ); rowIndex = i ; el . position . left = 0 ; el . position . top = rowOffset ; } } // If our child overflows the Layout, do not render it! // Disable this feature for now. if ( el . position . top + el . height > height ) { // Returning false tells blessed to ignore this child. // return false; } }; } }); for ( var i = 0 ; i < 10 ; i ++ ) { blessed . box ({ parent : layout , width : i % 2 === 0 ? 10 : 20 , height : i % 2 === 0 ? 5 : 10 , border : 'line' }); }","title":"Example"},{"location":"widgets/special-elements/OverlayImage/","text":"OverlayImage (from Box) \u00b6 Display an image in the terminal (jpeg, png, gif) using w3mimgdisplay. Requires w3m to be installed. X11 required: works in xterm, urxvt, and possibly other terminals. Options \u00b6 Inherits all from Box. file - Path to image. ansi - Render the file as ANSI art instead of using w3m to overlay Internally uses the ANSIImage element. See the ANSIImage element for more information/options. (Default: true ). w3m - Path to w3mimgdisplay. If a proper w3mimgdisplay path is not given, blessed will search the entire disk for the binary. search - Whether to search /usr , /bin , and /lib for w3mimgdisplay (Default: true ). Properties \u00b6 Inherits all from Box. Events \u00b6 Inherits all from Box. Methods \u00b6 Inherits all from Box. setImage(img, [callback]) - Set the image in the box to a new path. clearImage([callback]) - Clear the current image. imageSize(img, [callback]) - Get the size of an image file in pixels. termSize([callback]) - Get the size of the terminal in pixels. getPixelRatio([callback]) - Get the pixel to cell ratio for the terminal. Note: All methods above can be synchronous as long as the host version of node supports spawnSync .","title":"OverlayImage (from Box)"},{"location":"widgets/special-elements/OverlayImage/#overlayimage-from-box","text":"Display an image in the terminal (jpeg, png, gif) using w3mimgdisplay. Requires w3m to be installed. X11 required: works in xterm, urxvt, and possibly other terminals.","title":"OverlayImage (from Box)"},{"location":"widgets/special-elements/OverlayImage/#options","text":"Inherits all from Box. file - Path to image. ansi - Render the file as ANSI art instead of using w3m to overlay Internally uses the ANSIImage element. See the ANSIImage element for more information/options. (Default: true ). w3m - Path to w3mimgdisplay. If a proper w3mimgdisplay path is not given, blessed will search the entire disk for the binary. search - Whether to search /usr , /bin , and /lib for w3mimgdisplay (Default: true ).","title":"Options"},{"location":"widgets/special-elements/OverlayImage/#properties","text":"Inherits all from Box.","title":"Properties"},{"location":"widgets/special-elements/OverlayImage/#events","text":"Inherits all from Box.","title":"Events"},{"location":"widgets/special-elements/OverlayImage/#methods","text":"Inherits all from Box. setImage(img, [callback]) - Set the image in the box to a new path. clearImage([callback]) - Clear the current image. imageSize(img, [callback]) - Get the size of an image file in pixels. termSize([callback]) - Get the size of the terminal in pixels. getPixelRatio([callback]) - Get the pixel to cell ratio for the terminal. Note: All methods above can be synchronous as long as the host version of node supports spawnSync .","title":"Methods"},{"location":"widgets/special-elements/Terminal/","text":"Terminal (from Box) \u00b6 A box which spins up a pseudo terminal and renders the output. Useful for writing a terminal multiplexer, or something similar to an mc-like file manager. Requires term.js and pty.js to be installed. See example/multiplex.js for an example terminal multiplexer. Options \u00b6 Inherits all from Box. handler - Handler for input data. shell - Name of shell. $SHELL by default. args - Args for shell. cursor - Can be line , underline , and block . terminal - Terminal name (Default: xterm ). env - Object for process env. Other options similar to term.js'. Properties \u00b6 Inherits all from Box. term - Reference to the headless term.js terminal. pty - Reference to the pty.js pseudo terminal. Events \u00b6 Inherits all from Box. title - Window title from terminal. Other events similar to ScrollableBox. Methods \u00b6 Inherits all from Box. write(data) - Write data to the terminal. screenshot([xi, xl, yi, xl]) - Nearly identical to element.screenshot , however, the specified region includes the terminal's entire scrollback, rather than just what is visible on the screen. Other methods similar to ScrollableBox.","title":"Terminal (from Box)"},{"location":"widgets/special-elements/Terminal/#terminal-from-box","text":"A box which spins up a pseudo terminal and renders the output. Useful for writing a terminal multiplexer, or something similar to an mc-like file manager. Requires term.js and pty.js to be installed. See example/multiplex.js for an example terminal multiplexer.","title":"Terminal (from Box)"},{"location":"widgets/special-elements/Terminal/#options","text":"Inherits all from Box. handler - Handler for input data. shell - Name of shell. $SHELL by default. args - Args for shell. cursor - Can be line , underline , and block . terminal - Terminal name (Default: xterm ). env - Object for process env. Other options similar to term.js'.","title":"Options"},{"location":"widgets/special-elements/Terminal/#properties","text":"Inherits all from Box. term - Reference to the headless term.js terminal. pty - Reference to the pty.js pseudo terminal.","title":"Properties"},{"location":"widgets/special-elements/Terminal/#events","text":"Inherits all from Box. title - Window title from terminal. Other events similar to ScrollableBox.","title":"Events"},{"location":"widgets/special-elements/Terminal/#methods","text":"Inherits all from Box. write(data) - Write data to the terminal. screenshot([xi, xl, yi, xl]) - Nearly identical to element.screenshot , however, the specified region includes the terminal's entire scrollback, rather than just what is visible on the screen. Other methods similar to ScrollableBox.","title":"Methods"},{"location":"widgets/special-elements/Video/","text":"Video (from Box) \u00b6 A box which spins up a pseudo terminal in order to render a video via mplayer -vo caca or mpv --vo caca . Requires mplayer or mpv to be installed with libcaca support. Options \u00b6 Inherits all from Box. file - Video to play. start - Start time in seconds. Properties \u00b6 Inherits all from Box. tty - The terminal element running mplayer or mpv . Events \u00b6 Inherits all from Box. Methods \u00b6 Inherits all from Box.","title":"Video (from Box)"},{"location":"widgets/special-elements/Video/#video-from-box","text":"A box which spins up a pseudo terminal in order to render a video via mplayer -vo caca or mpv --vo caca . Requires mplayer or mpv to be installed with libcaca support.","title":"Video (from Box)"},{"location":"widgets/special-elements/Video/#options","text":"Inherits all from Box. file - Video to play. start - Start time in seconds.","title":"Options"},{"location":"widgets/special-elements/Video/#properties","text":"Inherits all from Box. tty - The terminal element running mplayer or mpv .","title":"Properties"},{"location":"widgets/special-elements/Video/#events","text":"Inherits all from Box.","title":"Events"},{"location":"widgets/special-elements/Video/#methods","text":"Inherits all from Box.","title":"Methods"}]}